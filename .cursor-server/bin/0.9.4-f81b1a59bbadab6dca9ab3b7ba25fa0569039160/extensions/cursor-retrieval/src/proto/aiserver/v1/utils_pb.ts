// @generated by protoc-gen-es v1.2.1 with parameter "target=ts"
// @generated from file aiserver/v1/utils.proto (package aiserver.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * @generated from enum aiserver.v1.FeatureType
 */
export enum FeatureType {
  /**
   * @generated from enum value: FEATURE_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: FEATURE_TYPE_EDIT = 1;
   */
  EDIT = 1,

  /**
   * @generated from enum value: FEATURE_TYPE_GENERATE = 2;
   */
  GENERATE = 2,

  /**
   * @generated from enum value: FEATURE_TYPE_INLINE_LONG_COMPLETION = 3;
   */
  INLINE_LONG_COMPLETION = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(FeatureType)
proto3.util.setEnumType(FeatureType, "aiserver.v1.FeatureType", [
  { no: 0, name: "FEATURE_TYPE_UNSPECIFIED" },
  { no: 1, name: "FEATURE_TYPE_EDIT" },
  { no: 2, name: "FEATURE_TYPE_GENERATE" },
  { no: 3, name: "FEATURE_TYPE_INLINE_LONG_COMPLETION" },
]);

/**
 * The positions here are unfortunately actually 0-indexed due to a bug and
 * has kept this way for backwards compatibility
 *
 * @generated from message aiserver.v1.CursorPosition
 */
export class CursorPosition extends Message<CursorPosition> {
  /**
   * the line number is 0-indexed
   *
   * @generated from field: int32 line = 1;
   */
  line = 0;

  /**
   * the column number is 0-indexed
   *
   * @generated from field: int32 column = 2;
   */
  column = 0;

  constructor(data?: PartialMessage<CursorPosition>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.CursorPosition";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "line", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "column", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CursorPosition {
    return new CursorPosition().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CursorPosition {
    return new CursorPosition().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CursorPosition {
    return new CursorPosition().fromJsonString(jsonString, options);
  }

  static equals(a: CursorPosition | PlainMessage<CursorPosition> | undefined, b: CursorPosition | PlainMessage<CursorPosition> | undefined): boolean {
    return proto3.util.equals(CursorPosition, a, b);
  }
}

/**
 * @generated from message aiserver.v1.SimpleRange
 */
export class SimpleRange extends Message<SimpleRange> {
  /**
   * 1-indexed
   *
   * @generated from field: int32 start_line_number = 1;
   */
  startLineNumber = 0;

  /**
   * 1-indexed
   *
   * @generated from field: int32 start_column = 2;
   */
  startColumn = 0;

  /**
   * 1-indexed
   *
   * @generated from field: int32 end_line_number_inclusive = 3;
   */
  endLineNumberInclusive = 0;

  /**
   * 1-indexed
   *
   * @generated from field: int32 end_column = 4;
   */
  endColumn = 0;

  constructor(data?: PartialMessage<SimpleRange>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.SimpleRange";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "start_line_number", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "start_column", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "end_line_number_inclusive", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "end_column", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SimpleRange {
    return new SimpleRange().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SimpleRange {
    return new SimpleRange().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SimpleRange {
    return new SimpleRange().fromJsonString(jsonString, options);
  }

  static equals(a: SimpleRange | PlainMessage<SimpleRange> | undefined, b: SimpleRange | PlainMessage<SimpleRange> | undefined): boolean {
    return proto3.util.equals(SimpleRange, a, b);
  }
}

/**
 * @generated from message aiserver.v1.LineRange
 */
export class LineRange extends Message<LineRange> {
  /**
   * 1-indexed
   *
   * @generated from field: int32 start_line_number = 1;
   */
  startLineNumber = 0;

  /**
   * 1-indexed
   *
   * @generated from field: int32 end_line_number_inclusive = 2;
   */
  endLineNumberInclusive = 0;

  constructor(data?: PartialMessage<LineRange>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.LineRange";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "start_line_number", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "end_line_number_inclusive", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LineRange {
    return new LineRange().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LineRange {
    return new LineRange().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LineRange {
    return new LineRange().fromJsonString(jsonString, options);
  }

  static equals(a: LineRange | PlainMessage<LineRange> | undefined, b: LineRange | PlainMessage<LineRange> | undefined): boolean {
    return proto3.util.equals(LineRange, a, b);
  }
}

/**
 * a single cursor (not a selection) has start_position == end_position
 * that should tell you everything you need to know
 *
 * @generated from message aiserver.v1.CursorRange
 */
export class CursorRange extends Message<CursorRange> {
  /**
   * start_position is inclusive
   *
   * @generated from field: aiserver.v1.CursorPosition start_position = 1;
   */
  startPosition?: CursorPosition;

  /**
   * end_position is exclusive!
   *
   * @generated from field: aiserver.v1.CursorPosition end_position = 2;
   */
  endPosition?: CursorPosition;

  constructor(data?: PartialMessage<CursorRange>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.CursorRange";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "start_position", kind: "message", T: CursorPosition },
    { no: 2, name: "end_position", kind: "message", T: CursorPosition },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CursorRange {
    return new CursorRange().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CursorRange {
    return new CursorRange().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CursorRange {
    return new CursorRange().fromJsonString(jsonString, options);
  }

  static equals(a: CursorRange | PlainMessage<CursorRange> | undefined, b: CursorRange | PlainMessage<CursorRange> | undefined): boolean {
    return proto3.util.equals(CursorRange, a, b);
  }
}

/**
 * / General info on a codeblock
 *
 * @generated from message aiserver.v1.CodeBlock
 */
export class CodeBlock extends Message<CodeBlock> {
  /**
   * @generated from field: string relative_workspace_path = 1;
   */
  relativeWorkspacePath = "";

  /**
   * @generated from field: optional string file_contents = 2;
   */
  fileContents?: string;

  /**
   * @generated from field: aiserver.v1.CursorRange range = 3;
   */
  range?: CursorRange;

  /**
   * @generated from field: string contents = 4;
   */
  contents = "";

  /**
   * @generated from field: aiserver.v1.CodeBlock.Signatures signatures = 5;
   */
  signatures?: CodeBlock_Signatures;

  constructor(data?: PartialMessage<CodeBlock>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.CodeBlock";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "file_contents", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "range", kind: "message", T: CursorRange },
    { no: 4, name: "contents", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "signatures", kind: "message", T: CodeBlock_Signatures },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CodeBlock {
    return new CodeBlock().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CodeBlock {
    return new CodeBlock().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CodeBlock {
    return new CodeBlock().fromJsonString(jsonString, options);
  }

  static equals(a: CodeBlock | PlainMessage<CodeBlock> | undefined, b: CodeBlock | PlainMessage<CodeBlock> | undefined): boolean {
    return proto3.util.equals(CodeBlock, a, b);
  }
}

/**
 * @generated from message aiserver.v1.CodeBlock.Signatures
 */
export class CodeBlock_Signatures extends Message<CodeBlock_Signatures> {
  /**
   * @generated from field: repeated aiserver.v1.CursorRange ranges = 1;
   */
  ranges: CursorRange[] = [];

  constructor(data?: PartialMessage<CodeBlock_Signatures>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.CodeBlock.Signatures";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ranges", kind: "message", T: CursorRange, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CodeBlock_Signatures {
    return new CodeBlock_Signatures().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CodeBlock_Signatures {
    return new CodeBlock_Signatures().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CodeBlock_Signatures {
    return new CodeBlock_Signatures().fromJsonString(jsonString, options);
  }

  static equals(a: CodeBlock_Signatures | PlainMessage<CodeBlock_Signatures> | undefined, b: CodeBlock_Signatures | PlainMessage<CodeBlock_Signatures> | undefined): boolean {
    return proto3.util.equals(CodeBlock_Signatures, a, b);
  }
}

/**
 * @generated from message aiserver.v1.File
 */
export class File extends Message<File> {
  /**
   * @generated from field: string relative_workspace_path = 1;
   */
  relativeWorkspacePath = "";

  /**
   * @generated from field: string contents = 2;
   */
  contents = "";

  constructor(data?: PartialMessage<File>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.File";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "contents", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): File {
    return new File().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): File {
    return new File().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): File {
    return new File().fromJsonString(jsonString, options);
  }

  static equals(a: File | PlainMessage<File> | undefined, b: File | PlainMessage<File> | undefined): boolean {
    return proto3.util.equals(File, a, b);
  }
}

/**
 * @generated from message aiserver.v1.Diagnostic
 */
export class Diagnostic extends Message<Diagnostic> {
  /**
   * @generated from field: string message = 1;
   */
  message = "";

  /**
   * @generated from field: aiserver.v1.CursorRange range = 2;
   */
  range?: CursorRange;

  /**
   * @generated from field: aiserver.v1.Diagnostic.DiagnosticSeverity severity = 3;
   */
  severity = Diagnostic_DiagnosticSeverity.UNSPECIFIED;

  constructor(data?: PartialMessage<Diagnostic>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.Diagnostic";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "range", kind: "message", T: CursorRange },
    { no: 3, name: "severity", kind: "enum", T: proto3.getEnumType(Diagnostic_DiagnosticSeverity) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Diagnostic {
    return new Diagnostic().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Diagnostic {
    return new Diagnostic().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Diagnostic {
    return new Diagnostic().fromJsonString(jsonString, options);
  }

  static equals(a: Diagnostic | PlainMessage<Diagnostic> | undefined, b: Diagnostic | PlainMessage<Diagnostic> | undefined): boolean {
    return proto3.util.equals(Diagnostic, a, b);
  }
}

/**
 * @generated from enum aiserver.v1.Diagnostic.DiagnosticSeverity
 */
export enum Diagnostic_DiagnosticSeverity {
  /**
   * @generated from enum value: DIAGNOSTIC_SEVERITY_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: DIAGNOSTIC_SEVERITY_ERROR = 1;
   */
  ERROR = 1,

  /**
   * @generated from enum value: DIAGNOSTIC_SEVERITY_WARNING = 2;
   */
  WARNING = 2,

  /**
   * @generated from enum value: DIAGNOSTIC_SEVERITY_INFORMATION = 3;
   */
  INFORMATION = 3,

  /**
   * @generated from enum value: DIAGNOSTIC_SEVERITY_HINT = 4;
   */
  HINT = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(Diagnostic_DiagnosticSeverity)
proto3.util.setEnumType(Diagnostic_DiagnosticSeverity, "aiserver.v1.Diagnostic.DiagnosticSeverity", [
  { no: 0, name: "DIAGNOSTIC_SEVERITY_UNSPECIFIED" },
  { no: 1, name: "DIAGNOSTIC_SEVERITY_ERROR" },
  { no: 2, name: "DIAGNOSTIC_SEVERITY_WARNING" },
  { no: 3, name: "DIAGNOSTIC_SEVERITY_INFORMATION" },
  { no: 4, name: "DIAGNOSTIC_SEVERITY_HINT" },
]);

/**
 * @generated from message aiserver.v1.CurrentFileInfo
 */
export class CurrentFileInfo extends Message<CurrentFileInfo> {
  /**
   * the relative path in the current workspace
   *
   * @generated from field: string relative_workspace_path = 1;
   */
  relativeWorkspacePath = "";

  /**
   * TODO: support both text files and notebook files
   * TODO: maybe we don't need to send up the entire file if we have a file sync
   * server?
   *
   * @generated from field: string contents = 2;
   */
  contents = "";

  /**
   * @generated from field: aiserver.v1.CursorPosition cursor_position = 3;
   */
  cursorPosition?: CursorPosition;

  /**
   * dataframes only exist in notebooks
   *
   * @generated from field: repeated aiserver.v1.DataframeInfo dataframes = 4;
   */
  dataframes: DataframeInfo[] = [];

  /**
   * @generated from field: string language_id = 5;
   */
  languageId = "";

  /**
   * TODO: support multiple selections
   * ARVIDTODO: add a SimpleRange selection too, that's always 1-indexed
   * we have a problem where the cursorrange is both annoying to deal with and
   * sometimes 0-indexed and sometimes 1-indexed
   *
   * @generated from field: aiserver.v1.CursorRange selection = 6;
   */
  selection?: CursorRange;

  /**
   * @generated from field: repeated aiserver.v1.Diagnostic diagnostics = 7;
   */
  diagnostics: Diagnostic[] = [];

  constructor(data?: PartialMessage<CurrentFileInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.CurrentFileInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "contents", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "cursor_position", kind: "message", T: CursorPosition },
    { no: 4, name: "dataframes", kind: "message", T: DataframeInfo, repeated: true },
    { no: 5, name: "language_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "selection", kind: "message", T: CursorRange },
    { no: 7, name: "diagnostics", kind: "message", T: Diagnostic, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CurrentFileInfo {
    return new CurrentFileInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CurrentFileInfo {
    return new CurrentFileInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CurrentFileInfo {
    return new CurrentFileInfo().fromJsonString(jsonString, options);
  }

  static equals(a: CurrentFileInfo | PlainMessage<CurrentFileInfo> | undefined, b: CurrentFileInfo | PlainMessage<CurrentFileInfo> | undefined): boolean {
    return proto3.util.equals(CurrentFileInfo, a, b);
  }
}

/**
 * @generated from message aiserver.v1.AzureState
 */
export class AzureState extends Message<AzureState> {
  /**
   * @generated from field: string api_key = 1;
   */
  apiKey = "";

  /**
   * @generated from field: string base_url = 2;
   */
  baseUrl = "";

  /**
   * @generated from field: string deployment = 3;
   */
  deployment = "";

  /**
   * @generated from field: bool use_azure = 4;
   */
  useAzure = false;

  constructor(data?: PartialMessage<AzureState>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.AzureState";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "api_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "base_url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "deployment", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "use_azure", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AzureState {
    return new AzureState().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AzureState {
    return new AzureState().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AzureState {
    return new AzureState().fromJsonString(jsonString, options);
  }

  static equals(a: AzureState | PlainMessage<AzureState> | undefined, b: AzureState | PlainMessage<AzureState> | undefined): boolean {
    return proto3.util.equals(AzureState, a, b);
  }
}

/**
 * @generated from message aiserver.v1.ModelDetails
 */
export class ModelDetails extends Message<ModelDetails> {
  /**
   * @generated from field: optional string model_name = 1;
   */
  modelName?: string;

  /**
   * @generated from field: optional string api_key = 2;
   */
  apiKey?: string;

  /**
   * @generated from field: optional bool enable_ghost_mode = 3;
   */
  enableGhostMode?: boolean;

  /**
   * @generated from field: optional aiserver.v1.AzureState azure_state = 4;
   */
  azureState?: AzureState;

  constructor(data?: PartialMessage<ModelDetails>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.ModelDetails";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "model_name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "api_key", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "enable_ghost_mode", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 4, name: "azure_state", kind: "message", T: AzureState, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ModelDetails {
    return new ModelDetails().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ModelDetails {
    return new ModelDetails().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ModelDetails {
    return new ModelDetails().fromJsonString(jsonString, options);
  }

  static equals(a: ModelDetails | PlainMessage<ModelDetails> | undefined, b: ModelDetails | PlainMessage<ModelDetails> | undefined): boolean {
    return proto3.util.equals(ModelDetails, a, b);
  }
}

/**
 * @generated from message aiserver.v1.DataframeInfo
 */
export class DataframeInfo extends Message<DataframeInfo> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: string shape = 2;
   */
  shape = "";

  /**
   * @generated from field: int32 data_dimensionality = 3;
   */
  dataDimensionality = 0;

  /**
   * @generated from field: repeated aiserver.v1.DataframeInfo.Column columns = 6;
   */
  columns: DataframeInfo_Column[] = [];

  /**
   * @generated from field: int32 row_count = 7;
   */
  rowCount = 0;

  /**
   * @generated from field: string index_column = 8;
   */
  indexColumn = "";

  constructor(data?: PartialMessage<DataframeInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.DataframeInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "shape", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "data_dimensionality", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 6, name: "columns", kind: "message", T: DataframeInfo_Column, repeated: true },
    { no: 7, name: "row_count", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 8, name: "index_column", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DataframeInfo {
    return new DataframeInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DataframeInfo {
    return new DataframeInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DataframeInfo {
    return new DataframeInfo().fromJsonString(jsonString, options);
  }

  static equals(a: DataframeInfo | PlainMessage<DataframeInfo> | undefined, b: DataframeInfo | PlainMessage<DataframeInfo> | undefined): boolean {
    return proto3.util.equals(DataframeInfo, a, b);
  }
}

/**
 * @generated from message aiserver.v1.DataframeInfo.Column
 */
export class DataframeInfo_Column extends Message<DataframeInfo_Column> {
  /**
   * @generated from field: string key = 1;
   */
  key = "";

  /**
   * @generated from field: string type = 2;
   */
  type = "";

  constructor(data?: PartialMessage<DataframeInfo_Column>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.DataframeInfo.Column";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DataframeInfo_Column {
    return new DataframeInfo_Column().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DataframeInfo_Column {
    return new DataframeInfo_Column().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DataframeInfo_Column {
    return new DataframeInfo_Column().fromJsonString(jsonString, options);
  }

  static equals(a: DataframeInfo_Column | PlainMessage<DataframeInfo_Column> | undefined, b: DataframeInfo_Column | PlainMessage<DataframeInfo_Column> | undefined): boolean {
    return proto3.util.equals(DataframeInfo_Column, a, b);
  }
}

/**
 * @generated from message aiserver.v1.LinterError
 */
export class LinterError extends Message<LinterError> {
  /**
   * @generated from field: string message = 1;
   */
  message = "";

  /**
   * @generated from field: aiserver.v1.CursorRange range = 2;
   */
  range?: CursorRange;

  constructor(data?: PartialMessage<LinterError>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.LinterError";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "range", kind: "message", T: CursorRange },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LinterError {
    return new LinterError().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LinterError {
    return new LinterError().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LinterError {
    return new LinterError().fromJsonString(jsonString, options);
  }

  static equals(a: LinterError | PlainMessage<LinterError> | undefined, b: LinterError | PlainMessage<LinterError> | undefined): boolean {
    return proto3.util.equals(LinterError, a, b);
  }
}

/**
 * @generated from message aiserver.v1.LinterErrors
 */
export class LinterErrors extends Message<LinterErrors> {
  /**
   * @generated from field: string relative_workspace_path = 1;
   */
  relativeWorkspacePath = "";

  /**
   * @generated from field: repeated aiserver.v1.LinterError errors = 2;
   */
  errors: LinterError[] = [];

  /**
   * @generated from field: string file_contents = 3;
   */
  fileContents = "";

  constructor(data?: PartialMessage<LinterErrors>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.LinterErrors";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "errors", kind: "message", T: LinterError, repeated: true },
    { no: 3, name: "file_contents", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LinterErrors {
    return new LinterErrors().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LinterErrors {
    return new LinterErrors().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LinterErrors {
    return new LinterErrors().fromJsonString(jsonString, options);
  }

  static equals(a: LinterErrors | PlainMessage<LinterErrors> | undefined, b: LinterErrors | PlainMessage<LinterErrors> | undefined): boolean {
    return proto3.util.equals(LinterErrors, a, b);
  }
}

/**
 * TODO: this should be more complicated
 * it should contain a bunch more things, etc
 * the explicit context is all the stuff that the user explicitly provides, and
 * could be strings like "never use unwrap" or other things like selecting files
 * or links etc
 *
 * @generated from message aiserver.v1.ExplicitContext
 */
export class ExplicitContext extends Message<ExplicitContext> {
  /**
   * @generated from field: string context = 1;
   */
  context = "";

  constructor(data?: PartialMessage<ExplicitContext>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.ExplicitContext";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "context", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExplicitContext {
    return new ExplicitContext().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExplicitContext {
    return new ExplicitContext().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExplicitContext {
    return new ExplicitContext().fromJsonString(jsonString, options);
  }

  static equals(a: ExplicitContext | PlainMessage<ExplicitContext> | undefined, b: ExplicitContext | PlainMessage<ExplicitContext> | undefined): boolean {
    return proto3.util.equals(ExplicitContext, a, b);
  }
}

/**
 * @generated from message aiserver.v1.PureMessage
 */
export class PureMessage extends Message<PureMessage> {
  /**
   * @generated from field: aiserver.v1.PureMessage.MessageType message_type = 1;
   */
  messageType = PureMessage_MessageType.UNSPECIFIED;

  /**
   * @generated from field: string content = 2;
   */
  content = "";

  constructor(data?: PartialMessage<PureMessage>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.PureMessage";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "message_type", kind: "enum", T: proto3.getEnumType(PureMessage_MessageType) },
    { no: 2, name: "content", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PureMessage {
    return new PureMessage().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PureMessage {
    return new PureMessage().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PureMessage {
    return new PureMessage().fromJsonString(jsonString, options);
  }

  static equals(a: PureMessage | PlainMessage<PureMessage> | undefined, b: PureMessage | PlainMessage<PureMessage> | undefined): boolean {
    return proto3.util.equals(PureMessage, a, b);
  }
}

/**
 * @generated from enum aiserver.v1.PureMessage.MessageType
 */
export enum PureMessage_MessageType {
  /**
   * @generated from enum value: MESSAGE_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: MESSAGE_TYPE_SYSTEM = 1;
   */
  SYSTEM = 1,

  /**
   * @generated from enum value: MESSAGE_TYPE_USER = 2;
   */
  USER = 2,

  /**
   * @generated from enum value: MESSAGE_TYPE_ASSISTANT = 3;
   */
  ASSISTANT = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(PureMessage_MessageType)
proto3.util.setEnumType(PureMessage_MessageType, "aiserver.v1.PureMessage.MessageType", [
  { no: 0, name: "MESSAGE_TYPE_UNSPECIFIED" },
  { no: 1, name: "MESSAGE_TYPE_SYSTEM" },
  { no: 2, name: "MESSAGE_TYPE_USER" },
  { no: 3, name: "MESSAGE_TYPE_ASSISTANT" },
]);

