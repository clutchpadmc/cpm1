// @generated by protoc-gen-es v1.2.1 with parameter "target=ts"
// @generated from file aiserver/v1/tools.proto (package aiserver.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { Diagnostic, SimpleRange } from './utils_pb';

/**
 * @generated from enum aiserver.v1.ShellType
 */
export enum ShellType {
  /**
   * @generated from enum value: SHELL_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: SHELL_TYPE_BASH = 1;
   */
  BASH = 1,

  /**
   * @generated from enum value: SHELL_TYPE_POWERSHELL = 2;
   */
  POWERSHELL = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(ShellType)
proto3.util.setEnumType(ShellType, "aiserver.v1.ShellType", [
  { no: 0, name: "SHELL_TYPE_UNSPECIFIED" },
  { no: 1, name: "SHELL_TYPE_BASH" },
  { no: 2, name: "SHELL_TYPE_POWERSHELL" },
]);

/**
 * @generated from enum aiserver.v1.BuiltinTool
 */
export enum BuiltinTool {
  /**
   * @generated from enum value: BUILTIN_TOOL_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Search can perform a search over the entire workspace. It can be a regex
   * search or a normal text search (and maybe even a semantic search?)
   *
   * @generated from enum value: BUILTIN_TOOL_SEARCH = 1;
   */
  SEARCH = 1,

  /**
   * @generated from enum value: BUILTIN_TOOL_READ_CHUNK = 2;
   */
  READ_CHUNK = 2,

  /**
   * @generated from enum value: BUILTIN_TOOL_GOTODEF = 3;
   */
  GOTODEF = 3,

  /**
   * @generated from enum value: BUILTIN_TOOL_EDIT = 4;
   */
  EDIT = 4,

  /**
   * @generated from enum value: BUILTIN_TOOL_UNDO_EDIT = 5;
   */
  UNDO_EDIT = 5,

  /**
   * @generated from enum value: BUILTIN_TOOL_END = 6;
   */
  END = 6,

  /**
   * @generated from enum value: BUILTIN_TOOL_NEW_FILE = 7;
   */
  NEW_FILE = 7,

  /**
   * @generated from enum value: BUILTIN_TOOL_ADD_TEST = 8;
   */
  ADD_TEST = 8,

  /**
   * @generated from enum value: BUILTIN_TOOL_RUN_TEST = 9;
   */
  RUN_TEST = 9,

  /**
   * @generated from enum value: BUILTIN_TOOL_DELETE_TEST = 10;
   */
  DELETE_TEST = 10,

  /**
   * @generated from enum value: BUILTIN_TOOL_SAVE_FILE = 11;
   */
  SAVE_FILE = 11,

  /**
   * @generated from enum value: BUILTIN_TOOL_GET_TESTS = 12;
   */
  GET_TESTS = 12,

  /**
   * @generated from enum value: BUILTIN_TOOL_GET_SYMBOLS = 13;
   */
  GET_SYMBOLS = 13,

  /**
   * @generated from enum value: BUILTIN_TOOL_SEMANTIC_SEARCH = 14;
   */
  SEMANTIC_SEARCH = 14,

  /**
   * @generated from enum value: BUILTIN_TOOL_GET_PROJECT_STRUCTURE = 15;
   */
  GET_PROJECT_STRUCTURE = 15,

  /**
   * @generated from enum value: BUILTIN_TOOL_CREATE_RM_FILES = 16;
   */
  CREATE_RM_FILES = 16,

  /**
   * @generated from enum value: BUILTIN_TOOL_RUN_TERMINAL_COMMANDS = 17;
   */
  RUN_TERMINAL_COMMANDS = 17,

  /**
   * @generated from enum value: BUILTIN_TOOL_NEW_EDIT = 18;
   */
  NEW_EDIT = 18,

  /**
   * @generated from enum value: BUILTIN_TOOL_READ_WITH_LINTER = 19;
   */
  READ_WITH_LINTER = 19,
}
// Retrieve enum metadata with: proto3.getEnumType(BuiltinTool)
proto3.util.setEnumType(BuiltinTool, "aiserver.v1.BuiltinTool", [
  { no: 0, name: "BUILTIN_TOOL_UNSPECIFIED" },
  { no: 1, name: "BUILTIN_TOOL_SEARCH" },
  { no: 2, name: "BUILTIN_TOOL_READ_CHUNK" },
  { no: 3, name: "BUILTIN_TOOL_GOTODEF" },
  { no: 4, name: "BUILTIN_TOOL_EDIT" },
  { no: 5, name: "BUILTIN_TOOL_UNDO_EDIT" },
  { no: 6, name: "BUILTIN_TOOL_END" },
  { no: 7, name: "BUILTIN_TOOL_NEW_FILE" },
  { no: 8, name: "BUILTIN_TOOL_ADD_TEST" },
  { no: 9, name: "BUILTIN_TOOL_RUN_TEST" },
  { no: 10, name: "BUILTIN_TOOL_DELETE_TEST" },
  { no: 11, name: "BUILTIN_TOOL_SAVE_FILE" },
  { no: 12, name: "BUILTIN_TOOL_GET_TESTS" },
  { no: 13, name: "BUILTIN_TOOL_GET_SYMBOLS" },
  { no: 14, name: "BUILTIN_TOOL_SEMANTIC_SEARCH" },
  { no: 15, name: "BUILTIN_TOOL_GET_PROJECT_STRUCTURE" },
  { no: 16, name: "BUILTIN_TOOL_CREATE_RM_FILES" },
  { no: 17, name: "BUILTIN_TOOL_RUN_TERMINAL_COMMANDS" },
  { no: 18, name: "BUILTIN_TOOL_NEW_EDIT" },
  { no: 19, name: "BUILTIN_TOOL_READ_WITH_LINTER" },
]);

/**
 * @generated from message aiserver.v1.BuiltinToolCall
 */
export class BuiltinToolCall extends Message<BuiltinToolCall> {
  /**
   * @generated from field: aiserver.v1.BuiltinTool tool = 1;
   */
  tool = BuiltinTool.UNSPECIFIED;

  /**
   * @generated from oneof aiserver.v1.BuiltinToolCall.params
   */
  params: {
    /**
     * @generated from field: aiserver.v1.SearchParams search_params = 2;
     */
    value: SearchParams;
    case: "searchParams";
  } | {
    /**
     * @generated from field: aiserver.v1.ReadChunkParams read_chunk_params = 3;
     */
    value: ReadChunkParams;
    case: "readChunkParams";
  } | {
    /**
     * @generated from field: aiserver.v1.GotodefParams gotodef_params = 4;
     */
    value: GotodefParams;
    case: "gotodefParams";
  } | {
    /**
     * @generated from field: aiserver.v1.EditParams edit_params = 5;
     */
    value: EditParams;
    case: "editParams";
  } | {
    /**
     * @generated from field: aiserver.v1.UndoEditParams undo_edit_params = 6;
     */
    value: UndoEditParams;
    case: "undoEditParams";
  } | {
    /**
     * @generated from field: aiserver.v1.EndParams end_params = 7;
     */
    value: EndParams;
    case: "endParams";
  } | {
    /**
     * @generated from field: aiserver.v1.NewFileParams new_file_params = 8;
     */
    value: NewFileParams;
    case: "newFileParams";
  } | {
    /**
     * @generated from field: aiserver.v1.AddTestParams add_test_params = 9;
     */
    value: AddTestParams;
    case: "addTestParams";
  } | {
    /**
     * @generated from field: aiserver.v1.RunTestParams run_test_params = 10;
     */
    value: RunTestParams;
    case: "runTestParams";
  } | {
    /**
     * @generated from field: aiserver.v1.DeleteTestParams delete_test_params = 11;
     */
    value: DeleteTestParams;
    case: "deleteTestParams";
  } | {
    /**
     * @generated from field: aiserver.v1.SaveFileParams save_file_params = 12;
     */
    value: SaveFileParams;
    case: "saveFileParams";
  } | {
    /**
     * @generated from field: aiserver.v1.GetTestsParams get_tests_params = 13;
     */
    value: GetTestsParams;
    case: "getTestsParams";
  } | {
    /**
     * @generated from field: aiserver.v1.GetSymbolsParams get_symbols_params = 14;
     */
    value: GetSymbolsParams;
    case: "getSymbolsParams";
  } | {
    /**
     * @generated from field: aiserver.v1.SemanticSearchParams semantic_search_params = 15;
     */
    value: SemanticSearchParams;
    case: "semanticSearchParams";
  } | {
    /**
     * @generated from field: aiserver.v1.GetProjectStructureParams get_project_structure_params = 16;
     */
    value: GetProjectStructureParams;
    case: "getProjectStructureParams";
  } | {
    /**
     * @generated from field: aiserver.v1.CreateRmFilesParams create_rm_files_params = 17;
     */
    value: CreateRmFilesParams;
    case: "createRmFilesParams";
  } | {
    /**
     * @generated from field: aiserver.v1.RunTerminalCommandsParams run_terminal_commands_params = 18;
     */
    value: RunTerminalCommandsParams;
    case: "runTerminalCommandsParams";
  } | {
    /**
     * @generated from field: aiserver.v1.NewEditParams new_edit_params = 19;
     */
    value: NewEditParams;
    case: "newEditParams";
  } | {
    /**
     * @generated from field: aiserver.v1.ReadWithLinterParams read_with_linter_params = 20;
     */
    value: ReadWithLinterParams;
    case: "readWithLinterParams";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<BuiltinToolCall>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.BuiltinToolCall";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "tool", kind: "enum", T: proto3.getEnumType(BuiltinTool) },
    { no: 2, name: "search_params", kind: "message", T: SearchParams, oneof: "params" },
    { no: 3, name: "read_chunk_params", kind: "message", T: ReadChunkParams, oneof: "params" },
    { no: 4, name: "gotodef_params", kind: "message", T: GotodefParams, oneof: "params" },
    { no: 5, name: "edit_params", kind: "message", T: EditParams, oneof: "params" },
    { no: 6, name: "undo_edit_params", kind: "message", T: UndoEditParams, oneof: "params" },
    { no: 7, name: "end_params", kind: "message", T: EndParams, oneof: "params" },
    { no: 8, name: "new_file_params", kind: "message", T: NewFileParams, oneof: "params" },
    { no: 9, name: "add_test_params", kind: "message", T: AddTestParams, oneof: "params" },
    { no: 10, name: "run_test_params", kind: "message", T: RunTestParams, oneof: "params" },
    { no: 11, name: "delete_test_params", kind: "message", T: DeleteTestParams, oneof: "params" },
    { no: 12, name: "save_file_params", kind: "message", T: SaveFileParams, oneof: "params" },
    { no: 13, name: "get_tests_params", kind: "message", T: GetTestsParams, oneof: "params" },
    { no: 14, name: "get_symbols_params", kind: "message", T: GetSymbolsParams, oneof: "params" },
    { no: 15, name: "semantic_search_params", kind: "message", T: SemanticSearchParams, oneof: "params" },
    { no: 16, name: "get_project_structure_params", kind: "message", T: GetProjectStructureParams, oneof: "params" },
    { no: 17, name: "create_rm_files_params", kind: "message", T: CreateRmFilesParams, oneof: "params" },
    { no: 18, name: "run_terminal_commands_params", kind: "message", T: RunTerminalCommandsParams, oneof: "params" },
    { no: 19, name: "new_edit_params", kind: "message", T: NewEditParams, oneof: "params" },
    { no: 20, name: "read_with_linter_params", kind: "message", T: ReadWithLinterParams, oneof: "params" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BuiltinToolCall {
    return new BuiltinToolCall().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BuiltinToolCall {
    return new BuiltinToolCall().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BuiltinToolCall {
    return new BuiltinToolCall().fromJsonString(jsonString, options);
  }

  static equals(a: BuiltinToolCall | PlainMessage<BuiltinToolCall> | undefined, b: BuiltinToolCall | PlainMessage<BuiltinToolCall> | undefined): boolean {
    return proto3.util.equals(BuiltinToolCall, a, b);
  }
}

/**
 * @generated from message aiserver.v1.BuiltinToolResult
 */
export class BuiltinToolResult extends Message<BuiltinToolResult> {
  /**
   * @generated from field: aiserver.v1.BuiltinTool tool = 1;
   */
  tool = BuiltinTool.UNSPECIFIED;

  /**
   * @generated from oneof aiserver.v1.BuiltinToolResult.result
   */
  result: {
    /**
     * @generated from field: aiserver.v1.SearchResult search_result = 2;
     */
    value: SearchResult;
    case: "searchResult";
  } | {
    /**
     * @generated from field: aiserver.v1.ReadChunkResult read_chunk_result = 3;
     */
    value: ReadChunkResult;
    case: "readChunkResult";
  } | {
    /**
     * @generated from field: aiserver.v1.GotodefResult gotodef_result = 4;
     */
    value: GotodefResult;
    case: "gotodefResult";
  } | {
    /**
     * @generated from field: aiserver.v1.EditResult edit_result = 5;
     */
    value: EditResult;
    case: "editResult";
  } | {
    /**
     * @generated from field: aiserver.v1.UndoEditResult undo_edit_result = 6;
     */
    value: UndoEditResult;
    case: "undoEditResult";
  } | {
    /**
     * @generated from field: aiserver.v1.EndResult end_result = 7;
     */
    value: EndResult;
    case: "endResult";
  } | {
    /**
     * @generated from field: aiserver.v1.NewFileResult new_file_result = 8;
     */
    value: NewFileResult;
    case: "newFileResult";
  } | {
    /**
     * @generated from field: aiserver.v1.AddTestResult add_test_result = 9;
     */
    value: AddTestResult;
    case: "addTestResult";
  } | {
    /**
     * @generated from field: aiserver.v1.RunTestResult run_test_result = 10;
     */
    value: RunTestResult;
    case: "runTestResult";
  } | {
    /**
     * @generated from field: aiserver.v1.DeleteTestResult delete_test_result = 11;
     */
    value: DeleteTestResult;
    case: "deleteTestResult";
  } | {
    /**
     * @generated from field: aiserver.v1.SaveFileResult save_file_result = 12;
     */
    value: SaveFileResult;
    case: "saveFileResult";
  } | {
    /**
     * @generated from field: aiserver.v1.GetTestsResult get_tests_result = 13;
     */
    value: GetTestsResult;
    case: "getTestsResult";
  } | {
    /**
     * @generated from field: aiserver.v1.GetSymbolsResult get_symbols_result = 14;
     */
    value: GetSymbolsResult;
    case: "getSymbolsResult";
  } | {
    /**
     * @generated from field: aiserver.v1.SemanticSearchResult semantic_search_result = 15;
     */
    value: SemanticSearchResult;
    case: "semanticSearchResult";
  } | {
    /**
     * @generated from field: aiserver.v1.GetProjectStructureResult get_project_structure_result = 16;
     */
    value: GetProjectStructureResult;
    case: "getProjectStructureResult";
  } | {
    /**
     * @generated from field: aiserver.v1.CreateRmFilesResult create_rm_files_result = 17;
     */
    value: CreateRmFilesResult;
    case: "createRmFilesResult";
  } | {
    /**
     * @generated from field: aiserver.v1.RunTerminalCommandsResult run_terminal_commands_result = 18;
     */
    value: RunTerminalCommandsResult;
    case: "runTerminalCommandsResult";
  } | {
    /**
     * @generated from field: aiserver.v1.NewEditResult new_edit_result = 19;
     */
    value: NewEditResult;
    case: "newEditResult";
  } | {
    /**
     * @generated from field: aiserver.v1.ReadWithLinterResult read_with_linter_result = 20;
     */
    value: ReadWithLinterResult;
    case: "readWithLinterResult";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<BuiltinToolResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.BuiltinToolResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "tool", kind: "enum", T: proto3.getEnumType(BuiltinTool) },
    { no: 2, name: "search_result", kind: "message", T: SearchResult, oneof: "result" },
    { no: 3, name: "read_chunk_result", kind: "message", T: ReadChunkResult, oneof: "result" },
    { no: 4, name: "gotodef_result", kind: "message", T: GotodefResult, oneof: "result" },
    { no: 5, name: "edit_result", kind: "message", T: EditResult, oneof: "result" },
    { no: 6, name: "undo_edit_result", kind: "message", T: UndoEditResult, oneof: "result" },
    { no: 7, name: "end_result", kind: "message", T: EndResult, oneof: "result" },
    { no: 8, name: "new_file_result", kind: "message", T: NewFileResult, oneof: "result" },
    { no: 9, name: "add_test_result", kind: "message", T: AddTestResult, oneof: "result" },
    { no: 10, name: "run_test_result", kind: "message", T: RunTestResult, oneof: "result" },
    { no: 11, name: "delete_test_result", kind: "message", T: DeleteTestResult, oneof: "result" },
    { no: 12, name: "save_file_result", kind: "message", T: SaveFileResult, oneof: "result" },
    { no: 13, name: "get_tests_result", kind: "message", T: GetTestsResult, oneof: "result" },
    { no: 14, name: "get_symbols_result", kind: "message", T: GetSymbolsResult, oneof: "result" },
    { no: 15, name: "semantic_search_result", kind: "message", T: SemanticSearchResult, oneof: "result" },
    { no: 16, name: "get_project_structure_result", kind: "message", T: GetProjectStructureResult, oneof: "result" },
    { no: 17, name: "create_rm_files_result", kind: "message", T: CreateRmFilesResult, oneof: "result" },
    { no: 18, name: "run_terminal_commands_result", kind: "message", T: RunTerminalCommandsResult, oneof: "result" },
    { no: 19, name: "new_edit_result", kind: "message", T: NewEditResult, oneof: "result" },
    { no: 20, name: "read_with_linter_result", kind: "message", T: ReadWithLinterResult, oneof: "result" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BuiltinToolResult {
    return new BuiltinToolResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BuiltinToolResult {
    return new BuiltinToolResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BuiltinToolResult {
    return new BuiltinToolResult().fromJsonString(jsonString, options);
  }

  static equals(a: BuiltinToolResult | PlainMessage<BuiltinToolResult> | undefined, b: BuiltinToolResult | PlainMessage<BuiltinToolResult> | undefined): boolean {
    return proto3.util.equals(BuiltinToolResult, a, b);
  }
}

/**
 * @generated from message aiserver.v1.ToolCall
 */
export class ToolCall extends Message<ToolCall> {
  /**
   * @generated from oneof aiserver.v1.ToolCall.tool_call
   */
  toolCall: {
    /**
     * @generated from field: aiserver.v1.BuiltinToolCall builtin_tool_call = 1;
     */
    value: BuiltinToolCall;
    case: "builtinToolCall";
  } | {
    /**
     * @generated from field: aiserver.v1.CustomToolCall custom_tool_call = 2;
     */
    value: CustomToolCall;
    case: "customToolCall";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ToolCall>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.ToolCall";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "builtin_tool_call", kind: "message", T: BuiltinToolCall, oneof: "tool_call" },
    { no: 2, name: "custom_tool_call", kind: "message", T: CustomToolCall, oneof: "tool_call" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ToolCall {
    return new ToolCall().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ToolCall {
    return new ToolCall().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ToolCall {
    return new ToolCall().fromJsonString(jsonString, options);
  }

  static equals(a: ToolCall | PlainMessage<ToolCall> | undefined, b: ToolCall | PlainMessage<ToolCall> | undefined): boolean {
    return proto3.util.equals(ToolCall, a, b);
  }
}

/**
 * @generated from message aiserver.v1.ToolResult
 */
export class ToolResult extends Message<ToolResult> {
  /**
   * @generated from oneof aiserver.v1.ToolResult.tool_result
   */
  toolResult: {
    /**
     * @generated from field: aiserver.v1.BuiltinToolResult builtin_tool_result = 1;
     */
    value: BuiltinToolResult;
    case: "builtinToolResult";
  } | {
    /**
     * @generated from field: aiserver.v1.CustomToolResult custom_tool_result = 2;
     */
    value: CustomToolResult;
    case: "customToolResult";
  } | {
    /**
     * @generated from field: aiserver.v1.ErrorToolResult error_tool_result = 3;
     */
    value: ErrorToolResult;
    case: "errorToolResult";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ToolResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.ToolResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "builtin_tool_result", kind: "message", T: BuiltinToolResult, oneof: "tool_result" },
    { no: 2, name: "custom_tool_result", kind: "message", T: CustomToolResult, oneof: "tool_result" },
    { no: 3, name: "error_tool_result", kind: "message", T: ErrorToolResult, oneof: "tool_result" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ToolResult {
    return new ToolResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ToolResult {
    return new ToolResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ToolResult {
    return new ToolResult().fromJsonString(jsonString, options);
  }

  static equals(a: ToolResult | PlainMessage<ToolResult> | undefined, b: ToolResult | PlainMessage<ToolResult> | undefined): boolean {
    return proto3.util.equals(ToolResult, a, b);
  }
}

/**
 * @generated from message aiserver.v1.ReadWithLinterParams
 */
export class ReadWithLinterParams extends Message<ReadWithLinterParams> {
  /**
   * @generated from field: string relative_workspace_path = 1;
   */
  relativeWorkspacePath = "";

  constructor(data?: PartialMessage<ReadWithLinterParams>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.ReadWithLinterParams";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReadWithLinterParams {
    return new ReadWithLinterParams().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReadWithLinterParams {
    return new ReadWithLinterParams().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReadWithLinterParams {
    return new ReadWithLinterParams().fromJsonString(jsonString, options);
  }

  static equals(a: ReadWithLinterParams | PlainMessage<ReadWithLinterParams> | undefined, b: ReadWithLinterParams | PlainMessage<ReadWithLinterParams> | undefined): boolean {
    return proto3.util.equals(ReadWithLinterParams, a, b);
  }
}

/**
 * @generated from message aiserver.v1.ReadWithLinterResult
 */
export class ReadWithLinterResult extends Message<ReadWithLinterResult> {
  /**
   * @generated from field: string contents = 1;
   */
  contents = "";

  /**
   * @generated from field: repeated aiserver.v1.Diagnostic diagnostics = 2;
   */
  diagnostics: Diagnostic[] = [];

  constructor(data?: PartialMessage<ReadWithLinterResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.ReadWithLinterResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "contents", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "diagnostics", kind: "message", T: Diagnostic, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReadWithLinterResult {
    return new ReadWithLinterResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReadWithLinterResult {
    return new ReadWithLinterResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReadWithLinterResult {
    return new ReadWithLinterResult().fromJsonString(jsonString, options);
  }

  static equals(a: ReadWithLinterResult | PlainMessage<ReadWithLinterResult> | undefined, b: ReadWithLinterResult | PlainMessage<ReadWithLinterResult> | undefined): boolean {
    return proto3.util.equals(ReadWithLinterResult, a, b);
  }
}

/**
 * @generated from message aiserver.v1.RunTerminalCommandsParams
 */
export class RunTerminalCommandsParams extends Message<RunTerminalCommandsParams> {
  /**
   * @generated from field: repeated string commands = 1;
   */
  commands: string[] = [];

  /**
   * @generated from field: string commands_uuid = 2;
   */
  commandsUuid = "";

  constructor(data?: PartialMessage<RunTerminalCommandsParams>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.RunTerminalCommandsParams";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "commands", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "commands_uuid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RunTerminalCommandsParams {
    return new RunTerminalCommandsParams().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RunTerminalCommandsParams {
    return new RunTerminalCommandsParams().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RunTerminalCommandsParams {
    return new RunTerminalCommandsParams().fromJsonString(jsonString, options);
  }

  static equals(a: RunTerminalCommandsParams | PlainMessage<RunTerminalCommandsParams> | undefined, b: RunTerminalCommandsParams | PlainMessage<RunTerminalCommandsParams> | undefined): boolean {
    return proto3.util.equals(RunTerminalCommandsParams, a, b);
  }
}

/**
 * @generated from message aiserver.v1.RunTerminalCommandsResult
 */
export class RunTerminalCommandsResult extends Message<RunTerminalCommandsResult> {
  /**
   * @generated from field: repeated string outputs = 1;
   */
  outputs: string[] = [];

  constructor(data?: PartialMessage<RunTerminalCommandsResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.RunTerminalCommandsResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "outputs", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RunTerminalCommandsResult {
    return new RunTerminalCommandsResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RunTerminalCommandsResult {
    return new RunTerminalCommandsResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RunTerminalCommandsResult {
    return new RunTerminalCommandsResult().fromJsonString(jsonString, options);
  }

  static equals(a: RunTerminalCommandsResult | PlainMessage<RunTerminalCommandsResult> | undefined, b: RunTerminalCommandsResult | PlainMessage<RunTerminalCommandsResult> | undefined): boolean {
    return proto3.util.equals(RunTerminalCommandsResult, a, b);
  }
}

/**
 * @generated from message aiserver.v1.CreateRmFilesParams
 */
export class CreateRmFilesParams extends Message<CreateRmFilesParams> {
  /**
   * @generated from field: repeated string removed_file_paths = 1;
   */
  removedFilePaths: string[] = [];

  /**
   * @generated from field: repeated string created_file_paths = 2;
   */
  createdFilePaths: string[] = [];

  /**
   * @generated from field: repeated string created_directory_paths = 3;
   */
  createdDirectoryPaths: string[] = [];

  constructor(data?: PartialMessage<CreateRmFilesParams>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.CreateRmFilesParams";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "removed_file_paths", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "created_file_paths", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "created_directory_paths", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateRmFilesParams {
    return new CreateRmFilesParams().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateRmFilesParams {
    return new CreateRmFilesParams().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateRmFilesParams {
    return new CreateRmFilesParams().fromJsonString(jsonString, options);
  }

  static equals(a: CreateRmFilesParams | PlainMessage<CreateRmFilesParams> | undefined, b: CreateRmFilesParams | PlainMessage<CreateRmFilesParams> | undefined): boolean {
    return proto3.util.equals(CreateRmFilesParams, a, b);
  }
}

/**
 * @generated from message aiserver.v1.CreateRmFilesResult
 */
export class CreateRmFilesResult extends Message<CreateRmFilesResult> {
  /**
   * @generated from field: repeated string created_file_paths = 1;
   */
  createdFilePaths: string[] = [];

  /**
   * @generated from field: repeated string removed_file_paths = 2;
   */
  removedFilePaths: string[] = [];

  constructor(data?: PartialMessage<CreateRmFilesResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.CreateRmFilesResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "created_file_paths", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "removed_file_paths", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateRmFilesResult {
    return new CreateRmFilesResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateRmFilesResult {
    return new CreateRmFilesResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateRmFilesResult {
    return new CreateRmFilesResult().fromJsonString(jsonString, options);
  }

  static equals(a: CreateRmFilesResult | PlainMessage<CreateRmFilesResult> | undefined, b: CreateRmFilesResult | PlainMessage<CreateRmFilesResult> | undefined): boolean {
    return proto3.util.equals(CreateRmFilesResult, a, b);
  }
}

/**
 * @generated from message aiserver.v1.GetProjectStructureParams
 */
export class GetProjectStructureParams extends Message<GetProjectStructureParams> {
  constructor(data?: PartialMessage<GetProjectStructureParams>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.GetProjectStructureParams";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetProjectStructureParams {
    return new GetProjectStructureParams().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetProjectStructureParams {
    return new GetProjectStructureParams().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetProjectStructureParams {
    return new GetProjectStructureParams().fromJsonString(jsonString, options);
  }

  static equals(a: GetProjectStructureParams | PlainMessage<GetProjectStructureParams> | undefined, b: GetProjectStructureParams | PlainMessage<GetProjectStructureParams> | undefined): boolean {
    return proto3.util.equals(GetProjectStructureParams, a, b);
  }
}

/**
 * @generated from message aiserver.v1.GetProjectStructureResult
 */
export class GetProjectStructureResult extends Message<GetProjectStructureResult> {
  /**
   * Folder top_level = 1;
   * TODO - or display this in a reasonable tree view
   *
   * @generated from field: repeated aiserver.v1.GetProjectStructureResult.File files = 1;
   */
  files: GetProjectStructureResult_File[] = [];

  /**
   * @generated from field: string root_workspace_path = 2;
   */
  rootWorkspacePath = "";

  constructor(data?: PartialMessage<GetProjectStructureResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.GetProjectStructureResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "files", kind: "message", T: GetProjectStructureResult_File, repeated: true },
    { no: 2, name: "root_workspace_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetProjectStructureResult {
    return new GetProjectStructureResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetProjectStructureResult {
    return new GetProjectStructureResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetProjectStructureResult {
    return new GetProjectStructureResult().fromJsonString(jsonString, options);
  }

  static equals(a: GetProjectStructureResult | PlainMessage<GetProjectStructureResult> | undefined, b: GetProjectStructureResult | PlainMessage<GetProjectStructureResult> | undefined): boolean {
    return proto3.util.equals(GetProjectStructureResult, a, b);
  }
}

/**
 * message Folder {
 *   string relative_workspace_path = 1;
 *   repeated Folder folders = 2;
 *   repeated File files = 3;
 * }
 *
 * @generated from message aiserver.v1.GetProjectStructureResult.File
 */
export class GetProjectStructureResult_File extends Message<GetProjectStructureResult_File> {
  /**
   * @generated from field: string relative_workspace_path = 1;
   */
  relativeWorkspacePath = "";

  /**
   * @generated from field: string outline = 2;
   */
  outline = "";

  constructor(data?: PartialMessage<GetProjectStructureResult_File>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.GetProjectStructureResult.File";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "outline", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetProjectStructureResult_File {
    return new GetProjectStructureResult_File().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetProjectStructureResult_File {
    return new GetProjectStructureResult_File().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetProjectStructureResult_File {
    return new GetProjectStructureResult_File().fromJsonString(jsonString, options);
  }

  static equals(a: GetProjectStructureResult_File | PlainMessage<GetProjectStructureResult_File> | undefined, b: GetProjectStructureResult_File | PlainMessage<GetProjectStructureResult_File> | undefined): boolean {
    return proto3.util.equals(GetProjectStructureResult_File, a, b);
  }
}

/**
 * @generated from message aiserver.v1.NewFileParams
 */
export class NewFileParams extends Message<NewFileParams> {
  /**
   * @generated from field: string relative_workspace_path = 1;
   */
  relativeWorkspacePath = "";

  constructor(data?: PartialMessage<NewFileParams>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.NewFileParams";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NewFileParams {
    return new NewFileParams().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NewFileParams {
    return new NewFileParams().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NewFileParams {
    return new NewFileParams().fromJsonString(jsonString, options);
  }

  static equals(a: NewFileParams | PlainMessage<NewFileParams> | undefined, b: NewFileParams | PlainMessage<NewFileParams> | undefined): boolean {
    return proto3.util.equals(NewFileParams, a, b);
  }
}

/**
 * @generated from message aiserver.v1.SemanticSearchParams
 */
export class SemanticSearchParams extends Message<SemanticSearchParams> {
  /**
   * @generated from field: string query = 1;
   */
  query = "";

  /**
   * @generated from field: optional string include_pattern = 2;
   */
  includePattern?: string;

  /**
   * @generated from field: optional string exclude_pattern = 3;
   */
  excludePattern?: string;

  /**
   * @generated from field: int32 top_k = 4;
   */
  topK = 0;

  /**
   * the index id to search over
   *
   * @generated from field: optional string index_id = 5;
   */
  indexId?: string;

  constructor(data?: PartialMessage<SemanticSearchParams>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.SemanticSearchParams";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "query", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "include_pattern", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "exclude_pattern", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "top_k", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 5, name: "index_id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SemanticSearchParams {
    return new SemanticSearchParams().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SemanticSearchParams {
    return new SemanticSearchParams().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SemanticSearchParams {
    return new SemanticSearchParams().fromJsonString(jsonString, options);
  }

  static equals(a: SemanticSearchParams | PlainMessage<SemanticSearchParams> | undefined, b: SemanticSearchParams | PlainMessage<SemanticSearchParams> | undefined): boolean {
    return proto3.util.equals(SemanticSearchParams, a, b);
  }
}

/**
 * @generated from message aiserver.v1.SemanticSearchResult
 */
export class SemanticSearchResult extends Message<SemanticSearchResult> {
  /**
   * there may be multiple chunks for a single file here
   *
   * @generated from field: repeated aiserver.v1.SemanticSearchResult.Item results = 1;
   */
  results: SemanticSearchResult_Item[] = [];

  constructor(data?: PartialMessage<SemanticSearchResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.SemanticSearchResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "results", kind: "message", T: SemanticSearchResult_Item, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SemanticSearchResult {
    return new SemanticSearchResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SemanticSearchResult {
    return new SemanticSearchResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SemanticSearchResult {
    return new SemanticSearchResult().fromJsonString(jsonString, options);
  }

  static equals(a: SemanticSearchResult | PlainMessage<SemanticSearchResult> | undefined, b: SemanticSearchResult | PlainMessage<SemanticSearchResult> | undefined): boolean {
    return proto3.util.equals(SemanticSearchResult, a, b);
  }
}

/**
 * @generated from message aiserver.v1.SemanticSearchResult.Item
 */
export class SemanticSearchResult_Item extends Message<SemanticSearchResult_Item> {
  /**
   * @generated from field: string relative_workspace_path = 1;
   */
  relativeWorkspacePath = "";

  /**
   * @generated from field: float score = 2;
   */
  score = 0;

  /**
   * @generated from field: string content = 3;
   */
  content = "";

  /**
   * @generated from field: aiserver.v1.SimpleRange range = 4;
   */
  range?: SimpleRange;

  constructor(data?: PartialMessage<SemanticSearchResult_Item>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.SemanticSearchResult.Item";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "score", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 3, name: "content", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "range", kind: "message", T: SimpleRange },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SemanticSearchResult_Item {
    return new SemanticSearchResult_Item().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SemanticSearchResult_Item {
    return new SemanticSearchResult_Item().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SemanticSearchResult_Item {
    return new SemanticSearchResult_Item().fromJsonString(jsonString, options);
  }

  static equals(a: SemanticSearchResult_Item | PlainMessage<SemanticSearchResult_Item> | undefined, b: SemanticSearchResult_Item | PlainMessage<SemanticSearchResult_Item> | undefined): boolean {
    return proto3.util.equals(SemanticSearchResult_Item, a, b);
  }
}

/**
 * @generated from message aiserver.v1.SearchParams
 */
export class SearchParams extends Message<SearchParams> {
  /**
   * @generated from field: string query = 1;
   */
  query = "";

  /**
   * @generated from field: bool regex = 2;
   */
  regex = false;

  /**
   * @generated from field: string include_pattern = 3;
   */
  includePattern = "";

  /**
   * @generated from field: string exclude_pattern = 4;
   */
  excludePattern = "";

  /**
   * if true, the query is interpreted as a filename search, eg a search for
   * "readme" finds all files that contain "readme" in their name
   *
   * @generated from field: bool filename_search = 5;
   */
  filenameSearch = false;

  constructor(data?: PartialMessage<SearchParams>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.SearchParams";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "query", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "regex", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "include_pattern", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "exclude_pattern", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "filename_search", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchParams {
    return new SearchParams().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchParams {
    return new SearchParams().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchParams {
    return new SearchParams().fromJsonString(jsonString, options);
  }

  static equals(a: SearchParams | PlainMessage<SearchParams> | undefined, b: SearchParams | PlainMessage<SearchParams> | undefined): boolean {
    return proto3.util.equals(SearchParams, a, b);
  }
}

/**
 * @generated from message aiserver.v1.SearchToolFileSearchResult
 */
export class SearchToolFileSearchResult extends Message<SearchToolFileSearchResult> {
  /**
   * @generated from field: string relative_workspace_path = 1;
   */
  relativeWorkspacePath = "";

  /**
   * @generated from field: int32 num_matches = 2;
   */
  numMatches = 0;

  /**
   * the lines returned here may or may not contain a match
   * if they don't contain a match it is because they are sent as context
   *
   * @generated from field: repeated aiserver.v1.SearchToolFileSearchResult.Line potentially_relevant_lines = 3;
   */
  potentiallyRelevantLines: SearchToolFileSearchResult_Line[] = [];

  /**
   * cropped = true iff not all matching lines are included
   * this will happen if the file has a lot of matches, or
   * if we simply don't have enough bandwidth to send all the files over
   *
   * @generated from field: bool cropped = 4;
   */
  cropped = false;

  constructor(data?: PartialMessage<SearchToolFileSearchResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.SearchToolFileSearchResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "num_matches", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "potentially_relevant_lines", kind: "message", T: SearchToolFileSearchResult_Line, repeated: true },
    { no: 4, name: "cropped", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchToolFileSearchResult {
    return new SearchToolFileSearchResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchToolFileSearchResult {
    return new SearchToolFileSearchResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchToolFileSearchResult {
    return new SearchToolFileSearchResult().fromJsonString(jsonString, options);
  }

  static equals(a: SearchToolFileSearchResult | PlainMessage<SearchToolFileSearchResult> | undefined, b: SearchToolFileSearchResult | PlainMessage<SearchToolFileSearchResult> | undefined): boolean {
    return proto3.util.equals(SearchToolFileSearchResult, a, b);
  }
}

/**
 * @generated from message aiserver.v1.SearchToolFileSearchResult.Line
 */
export class SearchToolFileSearchResult_Line extends Message<SearchToolFileSearchResult_Line> {
  /**
   * this line number is 1-indexed
   *
   * @generated from field: int32 line_number = 1;
   */
  lineNumber = 0;

  /**
   * the text is 1 line only
   *
   * @generated from field: string text = 2;
   */
  text = "";

  constructor(data?: PartialMessage<SearchToolFileSearchResult_Line>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.SearchToolFileSearchResult.Line";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "line_number", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "text", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchToolFileSearchResult_Line {
    return new SearchToolFileSearchResult_Line().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchToolFileSearchResult_Line {
    return new SearchToolFileSearchResult_Line().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchToolFileSearchResult_Line {
    return new SearchToolFileSearchResult_Line().fromJsonString(jsonString, options);
  }

  static equals(a: SearchToolFileSearchResult_Line | PlainMessage<SearchToolFileSearchResult_Line> | undefined, b: SearchToolFileSearchResult_Line | PlainMessage<SearchToolFileSearchResult_Line> | undefined): boolean {
    return proto3.util.equals(SearchToolFileSearchResult_Line, a, b);
  }
}

/**
 * @generated from message aiserver.v1.SearchResult
 */
export class SearchResult extends Message<SearchResult> {
  /**
   * we may or may not return all files
   *
   * @generated from field: repeated aiserver.v1.SearchToolFileSearchResult file_results = 1;
   */
  fileResults: SearchToolFileSearchResult[] = [];

  /**
   * num matches across all files
   *
   * @generated from field: int32 num_total_matches = 2;
   */
  numTotalMatches = 0;

  /**
   * num files that match
   *
   * @generated from field: int32 num_total_matched_files = 3;
   */
  numTotalMatchedFiles = 0;

  /**
   * @generated from field: bool num_total_may_be_incomplete = 4;
   */
  numTotalMayBeIncomplete = false;

  /**
   * true iff the search was for files only, and not for the context in the file
   *
   * @generated from field: bool files_only = 5;
   */
  filesOnly = false;

  constructor(data?: PartialMessage<SearchResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.SearchResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "file_results", kind: "message", T: SearchToolFileSearchResult, repeated: true },
    { no: 2, name: "num_total_matches", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "num_total_matched_files", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "num_total_may_be_incomplete", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "files_only", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchResult {
    return new SearchResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchResult {
    return new SearchResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchResult {
    return new SearchResult().fromJsonString(jsonString, options);
  }

  static equals(a: SearchResult | PlainMessage<SearchResult> | undefined, b: SearchResult | PlainMessage<SearchResult> | undefined): boolean {
    return proto3.util.equals(SearchResult, a, b);
  }
}

/**
 * @generated from message aiserver.v1.ReadChunkParams
 */
export class ReadChunkParams extends Message<ReadChunkParams> {
  /**
   * @generated from field: string relative_workspace_path = 1;
   */
  relativeWorkspacePath = "";

  /**
   * start_line is inclusive and 1-indexed
   *
   * @generated from field: int32 start_line_number = 2;
   */
  startLineNumber = 0;

  /**
   * if this is not provided, the whole file is read
   *
   * @generated from field: optional int32 num_lines = 3;
   */
  numLines?: number;

  constructor(data?: PartialMessage<ReadChunkParams>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.ReadChunkParams";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "start_line_number", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "num_lines", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReadChunkParams {
    return new ReadChunkParams().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReadChunkParams {
    return new ReadChunkParams().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReadChunkParams {
    return new ReadChunkParams().fromJsonString(jsonString, options);
  }

  static equals(a: ReadChunkParams | PlainMessage<ReadChunkParams> | undefined, b: ReadChunkParams | PlainMessage<ReadChunkParams> | undefined): boolean {
    return proto3.util.equals(ReadChunkParams, a, b);
  }
}

/**
 * @generated from message aiserver.v1.ReadChunkResult
 */
export class ReadChunkResult extends Message<ReadChunkResult> {
  /**
   * @generated from field: string relative_workspace_path = 1;
   */
  relativeWorkspacePath = "";

  /**
   * 1-indexed
   *
   * @generated from field: int32 start_line_number = 2;
   */
  startLineNumber = 0;

  /**
   * @generated from field: repeated string lines = 3;
   */
  lines: string[] = [];

  /**
   * @generated from field: int32 total_num_lines = 4;
   */
  totalNumLines = 0;

  /**
   * if the result was cropped, and not the entire result that was requested
   * this happens on really really large files
   *
   * @generated from field: bool cropped = 5;
   */
  cropped = false;

  constructor(data?: PartialMessage<ReadChunkResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.ReadChunkResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "start_line_number", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "lines", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "total_num_lines", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 5, name: "cropped", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReadChunkResult {
    return new ReadChunkResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReadChunkResult {
    return new ReadChunkResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReadChunkResult {
    return new ReadChunkResult().fromJsonString(jsonString, options);
  }

  static equals(a: ReadChunkResult | PlainMessage<ReadChunkResult> | undefined, b: ReadChunkResult | PlainMessage<ReadChunkResult> | undefined): boolean {
    return proto3.util.equals(ReadChunkResult, a, b);
  }
}

/**
 * for now, no arguments here. we just undo the latest edit
 *
 * @generated from message aiserver.v1.UndoEditParams
 */
export class UndoEditParams extends Message<UndoEditParams> {
  constructor(data?: PartialMessage<UndoEditParams>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.UndoEditParams";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UndoEditParams {
    return new UndoEditParams().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UndoEditParams {
    return new UndoEditParams().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UndoEditParams {
    return new UndoEditParams().fromJsonString(jsonString, options);
  }

  static equals(a: UndoEditParams | PlainMessage<UndoEditParams> | undefined, b: UndoEditParams | PlainMessage<UndoEditParams> | undefined): boolean {
    return proto3.util.equals(UndoEditParams, a, b);
  }
}

/**
 * @generated from message aiserver.v1.EndParams
 */
export class EndParams extends Message<EndParams> {
  constructor(data?: PartialMessage<EndParams>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.EndParams";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EndParams {
    return new EndParams().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EndParams {
    return new EndParams().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EndParams {
    return new EndParams().fromJsonString(jsonString, options);
  }

  static equals(a: EndParams | PlainMessage<EndParams> | undefined, b: EndParams | PlainMessage<EndParams> | undefined): boolean {
    return proto3.util.equals(EndParams, a, b);
  }
}

/**
 * @generated from message aiserver.v1.NewFileResult
 */
export class NewFileResult extends Message<NewFileResult> {
  /**
   * @generated from field: string relative_workspace_path = 1;
   */
  relativeWorkspacePath = "";

  /**
   * @generated from field: int32 file_total_lines = 2;
   */
  fileTotalLines = 0;

  constructor(data?: PartialMessage<NewFileResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.NewFileResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "file_total_lines", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NewFileResult {
    return new NewFileResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NewFileResult {
    return new NewFileResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NewFileResult {
    return new NewFileResult().fromJsonString(jsonString, options);
  }

  static equals(a: NewFileResult | PlainMessage<NewFileResult> | undefined, b: NewFileResult | PlainMessage<NewFileResult> | undefined): boolean {
    return proto3.util.equals(NewFileResult, a, b);
  }
}

/**
 * @generated from message aiserver.v1.UndoEditResult
 */
export class UndoEditResult extends Message<UndoEditResult> {
  /**
   * for now we return linter errors here. in the future we may want to return
   * them in an interrupt since they are technically asynchronous
   *
   * @generated from field: repeated string feedback = 1;
   */
  feedback: string[] = [];

  /**
   * Makes it easier to confirm what is changing
   *
   * @generated from field: string relative_workspace_path = 4;
   */
  relativeWorkspacePath = "";

  /**
   * we return the change +- 5 lines
   *
   * @generated from field: int32 context_start_line_number = 2;
   */
  contextStartLineNumber = 0;

  /**
   * @generated from field: repeated string context_lines = 3;
   */
  contextLines: string[] = [];

  /**
   * @generated from field: int32 context_total_num_lines = 5;
   */
  contextTotalNumLines = 0;

  /**
   * @generated from field: int32 file_total_lines = 6;
   */
  fileTotalLines = 0;

  constructor(data?: PartialMessage<UndoEditResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.UndoEditResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "feedback", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "relative_workspace_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "context_start_line_number", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "context_lines", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "context_total_num_lines", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 6, name: "file_total_lines", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UndoEditResult {
    return new UndoEditResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UndoEditResult {
    return new UndoEditResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UndoEditResult {
    return new UndoEditResult().fromJsonString(jsonString, options);
  }

  static equals(a: UndoEditResult | PlainMessage<UndoEditResult> | undefined, b: UndoEditResult | PlainMessage<UndoEditResult> | undefined): boolean {
    return proto3.util.equals(UndoEditResult, a, b);
  }
}

/**
 * @generated from message aiserver.v1.EndResult
 */
export class EndResult extends Message<EndResult> {
  constructor(data?: PartialMessage<EndResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.EndResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EndResult {
    return new EndResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EndResult {
    return new EndResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EndResult {
    return new EndResult().fromJsonString(jsonString, options);
  }

  static equals(a: EndResult | PlainMessage<EndResult> | undefined, b: EndResult | PlainMessage<EndResult> | undefined): boolean {
    return proto3.util.equals(EndResult, a, b);
  }
}

/**
 * @generated from message aiserver.v1.CustomToolCall
 */
export class CustomToolCall extends Message<CustomToolCall> {
  /**
   * @generated from field: string tool_id = 1;
   */
  toolId = "";

  /**
   * @generated from field: string params = 2;
   */
  params = "";

  constructor(data?: PartialMessage<CustomToolCall>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.CustomToolCall";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "tool_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "params", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CustomToolCall {
    return new CustomToolCall().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CustomToolCall {
    return new CustomToolCall().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CustomToolCall {
    return new CustomToolCall().fromJsonString(jsonString, options);
  }

  static equals(a: CustomToolCall | PlainMessage<CustomToolCall> | undefined, b: CustomToolCall | PlainMessage<CustomToolCall> | undefined): boolean {
    return proto3.util.equals(CustomToolCall, a, b);
  }
}

/**
 * @generated from message aiserver.v1.ScratchpadResult
 */
export class ScratchpadResult extends Message<ScratchpadResult> {
  constructor(data?: PartialMessage<ScratchpadResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.ScratchpadResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ScratchpadResult {
    return new ScratchpadResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ScratchpadResult {
    return new ScratchpadResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ScratchpadResult {
    return new ScratchpadResult().fromJsonString(jsonString, options);
  }

  static equals(a: ScratchpadResult | PlainMessage<ScratchpadResult> | undefined, b: ScratchpadResult | PlainMessage<ScratchpadResult> | undefined): boolean {
    return proto3.util.equals(ScratchpadResult, a, b);
  }
}

/**
 * @generated from message aiserver.v1.CustomToolResult
 */
export class CustomToolResult extends Message<CustomToolResult> {
  /**
   * @generated from field: string tool_id = 1;
   */
  toolId = "";

  /**
   * @generated from field: string result = 2;
   */
  result = "";

  constructor(data?: PartialMessage<CustomToolResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.CustomToolResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "tool_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "result", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CustomToolResult {
    return new CustomToolResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CustomToolResult {
    return new CustomToolResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CustomToolResult {
    return new CustomToolResult().fromJsonString(jsonString, options);
  }

  static equals(a: CustomToolResult | PlainMessage<CustomToolResult> | undefined, b: CustomToolResult | PlainMessage<CustomToolResult> | undefined): boolean {
    return proto3.util.equals(CustomToolResult, a, b);
  }
}

/**
 * @generated from message aiserver.v1.GotodefParams
 */
export class GotodefParams extends Message<GotodefParams> {
  /**
   * @generated from field: string relative_workspace_path = 1;
   */
  relativeWorkspacePath = "";

  /**
   * line number is 1-indexed
   *
   * @generated from field: int32 line_number = 2;
   */
  lineNumber = 0;

  /**
   * @generated from field: string symbol = 3;
   */
  symbol = "";

  constructor(data?: PartialMessage<GotodefParams>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.GotodefParams";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "line_number", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "symbol", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GotodefParams {
    return new GotodefParams().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GotodefParams {
    return new GotodefParams().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GotodefParams {
    return new GotodefParams().fromJsonString(jsonString, options);
  }

  static equals(a: GotodefParams | PlainMessage<GotodefParams> | undefined, b: GotodefParams | PlainMessage<GotodefParams> | undefined): boolean {
    return proto3.util.equals(GotodefParams, a, b);
  }
}

/**
 * @generated from message aiserver.v1.GotodefToolFileSearchResult
 */
export class GotodefToolFileSearchResult extends Message<GotodefToolFileSearchResult> {
  /**
   * @generated from field: string relative_workspace_path = 1;
   */
  relativeWorkspacePath = "";

  /**
   * the lines returned here may or may not contain a match
   * if they don't contain a match it is because they are sent as context
   *
   * @generated from field: repeated aiserver.v1.GotodefToolFileSearchResult.Line potentially_relevant_lines = 3;
   */
  potentiallyRelevantLines: GotodefToolFileSearchResult_Line[] = [];

  constructor(data?: PartialMessage<GotodefToolFileSearchResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.GotodefToolFileSearchResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "potentially_relevant_lines", kind: "message", T: GotodefToolFileSearchResult_Line, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GotodefToolFileSearchResult {
    return new GotodefToolFileSearchResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GotodefToolFileSearchResult {
    return new GotodefToolFileSearchResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GotodefToolFileSearchResult {
    return new GotodefToolFileSearchResult().fromJsonString(jsonString, options);
  }

  static equals(a: GotodefToolFileSearchResult | PlainMessage<GotodefToolFileSearchResult> | undefined, b: GotodefToolFileSearchResult | PlainMessage<GotodefToolFileSearchResult> | undefined): boolean {
    return proto3.util.equals(GotodefToolFileSearchResult, a, b);
  }
}

/**
 * @generated from message aiserver.v1.GotodefToolFileSearchResult.Line
 */
export class GotodefToolFileSearchResult_Line extends Message<GotodefToolFileSearchResult_Line> {
  /**
   * this line number is 1-indexed
   *
   * @generated from field: int32 line_number = 1;
   */
  lineNumber = 0;

  /**
   * the text is 1 line only
   *
   * @generated from field: string text = 2;
   */
  text = "";

  constructor(data?: PartialMessage<GotodefToolFileSearchResult_Line>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.GotodefToolFileSearchResult.Line";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "line_number", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "text", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GotodefToolFileSearchResult_Line {
    return new GotodefToolFileSearchResult_Line().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GotodefToolFileSearchResult_Line {
    return new GotodefToolFileSearchResult_Line().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GotodefToolFileSearchResult_Line {
    return new GotodefToolFileSearchResult_Line().fromJsonString(jsonString, options);
  }

  static equals(a: GotodefToolFileSearchResult_Line | PlainMessage<GotodefToolFileSearchResult_Line> | undefined, b: GotodefToolFileSearchResult_Line | PlainMessage<GotodefToolFileSearchResult_Line> | undefined): boolean {
    return proto3.util.equals(GotodefToolFileSearchResult_Line, a, b);
  }
}

/**
 * @generated from message aiserver.v1.GotodefResult
 */
export class GotodefResult extends Message<GotodefResult> {
  /**
   * @generated from field: repeated aiserver.v1.GotodefToolFileSearchResult results = 1;
   */
  results: GotodefToolFileSearchResult[] = [];

  constructor(data?: PartialMessage<GotodefResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.GotodefResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "results", kind: "message", T: GotodefToolFileSearchResult, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GotodefResult {
    return new GotodefResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GotodefResult {
    return new GotodefResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GotodefResult {
    return new GotodefResult().fromJsonString(jsonString, options);
  }

  static equals(a: GotodefResult | PlainMessage<GotodefResult> | undefined, b: GotodefResult | PlainMessage<GotodefResult> | undefined): boolean {
    return proto3.util.equals(GotodefResult, a, b);
  }
}

/**
 * @generated from message aiserver.v1.ErrorToolResult
 */
export class ErrorToolResult extends Message<ErrorToolResult> {
  /**
   * the error is just a string. because the model can only read strings lol
   *
   * @generated from field: string error_message = 1;
   */
  errorMessage = "";

  constructor(data?: PartialMessage<ErrorToolResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.ErrorToolResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "error_message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ErrorToolResult {
    return new ErrorToolResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ErrorToolResult {
    return new ErrorToolResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ErrorToolResult {
    return new ErrorToolResult().fromJsonString(jsonString, options);
  }

  static equals(a: ErrorToolResult | PlainMessage<ErrorToolResult> | undefined, b: ErrorToolResult | PlainMessage<ErrorToolResult> | undefined): boolean {
    return proto3.util.equals(ErrorToolResult, a, b);
  }
}

/**
 * @generated from message aiserver.v1.NewEditParams
 */
export class NewEditParams extends Message<NewEditParams> {
  /**
   * @generated from field: string relative_workspace_path = 1;
   */
  relativeWorkspacePath = "";

  /**
   * line number is 1-indexed
   *
   * @generated from field: optional int32 start_line_number = 2;
   */
  startLineNumber?: number;

  /**
   * @generated from field: optional int32 end_line_number = 3;
   */
  endLineNumber?: number;

  /**
   * @generated from field: string text = 4;
   */
  text = "";

  /**
   * @generated from field: string edit_id = 5;
   */
  editId = "";

  /**
   * @generated from field: bool first_edit = 6;
   */
  firstEdit = false;

  constructor(data?: PartialMessage<NewEditParams>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.NewEditParams";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "start_line_number", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 3, name: "end_line_number", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 4, name: "text", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "edit_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "first_edit", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NewEditParams {
    return new NewEditParams().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NewEditParams {
    return new NewEditParams().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NewEditParams {
    return new NewEditParams().fromJsonString(jsonString, options);
  }

  static equals(a: NewEditParams | PlainMessage<NewEditParams> | undefined, b: NewEditParams | PlainMessage<NewEditParams> | undefined): boolean {
    return proto3.util.equals(NewEditParams, a, b);
  }
}

/**
 * Nothing needed for now
 *
 * @generated from message aiserver.v1.NewEditResult
 */
export class NewEditResult extends Message<NewEditResult> {
  constructor(data?: PartialMessage<NewEditResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.NewEditResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NewEditResult {
    return new NewEditResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NewEditResult {
    return new NewEditResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NewEditResult {
    return new NewEditResult().fromJsonString(jsonString, options);
  }

  static equals(a: NewEditResult | PlainMessage<NewEditResult> | undefined, b: NewEditResult | PlainMessage<NewEditResult> | undefined): boolean {
    return proto3.util.equals(NewEditResult, a, b);
  }
}

/**
 * @generated from message aiserver.v1.EditParams
 */
export class EditParams extends Message<EditParams> {
  /**
   * @generated from field: string relative_workspace_path = 1;
   */
  relativeWorkspacePath = "";

  /**
   * line number is 1-indexed
   * if null, then insert at cursor position (if exists) or at the end of the
   * file
   *
   * @generated from field: optional int32 line_number = 2;
   */
  lineNumber?: number;

  /**
   * how many lines to replace. 0 means a pure insert
   *
   * @generated from field: int32 replace_num_lines = 3;
   */
  replaceNumLines = 0;

  /**
   * @generated from field: repeated string new_lines = 4;
   */
  newLines: string[] = [];

  /**
   * if true, we ignore the previous few lines
   *
   * @generated from field: optional bool replace_whole_file = 7;
   */
  replaceWholeFile?: boolean;

  /**
   * the model edit may be streamed in. to identify a single model edit, we give
   * an id to each model edit, such that a streamed sequence of edits all have
   * the same edit id and can be identified as a single edit
   * this edit ID is also used to identify the edit when undoing it
   *
   * @generated from field: string edit_id = 5;
   */
  editId = "";

  /**
   * @generated from field: aiserver.v1.EditParams.FrontendEditType frontend_edit_type = 6;
   */
  frontendEditType = EditParams_FrontendEditType.UNSPECIFIED;

  /**
   * @generated from field: optional bool auto_fix_all_linter_errors_in_file = 8;
   */
  autoFixAllLinterErrorsInFile?: boolean;

  constructor(data?: PartialMessage<EditParams>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.EditParams";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "line_number", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 3, name: "replace_num_lines", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "new_lines", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 7, name: "replace_whole_file", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 5, name: "edit_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "frontend_edit_type", kind: "enum", T: proto3.getEnumType(EditParams_FrontendEditType) },
    { no: 8, name: "auto_fix_all_linter_errors_in_file", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EditParams {
    return new EditParams().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EditParams {
    return new EditParams().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EditParams {
    return new EditParams().fromJsonString(jsonString, options);
  }

  static equals(a: EditParams | PlainMessage<EditParams> | undefined, b: EditParams | PlainMessage<EditParams> | undefined): boolean {
    return proto3.util.equals(EditParams, a, b);
  }
}

/**
 * what kind of edit version to use on the frontend
 * this is useful for experimentation
 *
 * @generated from enum aiserver.v1.EditParams.FrontendEditType
 */
export enum EditParams_FrontendEditType {
  /**
   * @generated from enum value: FRONTEND_EDIT_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: FRONTEND_EDIT_TYPE_INLINE_DIFFS = 1;
   */
  INLINE_DIFFS = 1,

  /**
   * @generated from enum value: FRONTEND_EDIT_TYPE_SIMPLE = 2;
   */
  SIMPLE = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(EditParams_FrontendEditType)
proto3.util.setEnumType(EditParams_FrontendEditType, "aiserver.v1.EditParams.FrontendEditType", [
  { no: 0, name: "FRONTEND_EDIT_TYPE_UNSPECIFIED" },
  { no: 1, name: "FRONTEND_EDIT_TYPE_INLINE_DIFFS" },
  { no: 2, name: "FRONTEND_EDIT_TYPE_SIMPLE" },
]);

/**
 * @generated from message aiserver.v1.EditResult
 */
export class EditResult extends Message<EditResult> {
  /**
   * for now we return linter errors here. in the future we may want to return
   * them in an interrupt since they are technically asynchronous
   *
   * @generated from field: repeated string feedback = 1;
   */
  feedback: string[] = [];

  /**
   * we return the change +- 5 lines
   *
   * @generated from field: int32 context_start_line_number = 2;
   */
  contextStartLineNumber = 0;

  /**
   * @generated from field: repeated string context_lines = 3;
   */
  contextLines: string[] = [];

  /**
   * Add the file name
   *
   * @generated from field: string file = 4;
   */
  file = "";

  /**
   * @generated from field: int32 file_total_lines = 5;
   */
  fileTotalLines = 0;

  /**
   * @generated from field: repeated aiserver.v1.EditResult.Feedback structured_feedback = 6;
   */
  structuredFeedback: EditResult_Feedback[] = [];

  constructor(data?: PartialMessage<EditResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.EditResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "feedback", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "context_start_line_number", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "context_lines", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "file", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "file_total_lines", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 6, name: "structured_feedback", kind: "message", T: EditResult_Feedback, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EditResult {
    return new EditResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EditResult {
    return new EditResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EditResult {
    return new EditResult().fromJsonString(jsonString, options);
  }

  static equals(a: EditResult | PlainMessage<EditResult> | undefined, b: EditResult | PlainMessage<EditResult> | undefined): boolean {
    return proto3.util.equals(EditResult, a, b);
  }
}

/**
 * @generated from message aiserver.v1.EditResult.RelatedInformation
 */
export class EditResult_RelatedInformation extends Message<EditResult_RelatedInformation> {
  /**
   * @generated from field: string message = 1;
   */
  message = "";

  /**
   * @generated from field: int32 start_line_number = 2;
   */
  startLineNumber = 0;

  /**
   * @generated from field: int32 end_line_number = 3;
   */
  endLineNumber = 0;

  /**
   * @generated from field: string relative_workspace_path = 4;
   */
  relativeWorkspacePath = "";

  constructor(data?: PartialMessage<EditResult_RelatedInformation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.EditResult.RelatedInformation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "start_line_number", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "end_line_number", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "relative_workspace_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EditResult_RelatedInformation {
    return new EditResult_RelatedInformation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EditResult_RelatedInformation {
    return new EditResult_RelatedInformation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EditResult_RelatedInformation {
    return new EditResult_RelatedInformation().fromJsonString(jsonString, options);
  }

  static equals(a: EditResult_RelatedInformation | PlainMessage<EditResult_RelatedInformation> | undefined, b: EditResult_RelatedInformation | PlainMessage<EditResult_RelatedInformation> | undefined): boolean {
    return proto3.util.equals(EditResult_RelatedInformation, a, b);
  }
}

/**
 * @generated from message aiserver.v1.EditResult.Feedback
 */
export class EditResult_Feedback extends Message<EditResult_Feedback> {
  /**
   * @generated from field: string message = 1;
   */
  message = "";

  /**
   * @generated from field: string severity = 2;
   */
  severity = "";

  /**
   * @generated from field: int32 start_line_number = 3;
   */
  startLineNumber = 0;

  /**
   * @generated from field: int32 end_line_number = 4;
   */
  endLineNumber = 0;

  /**
   * @generated from field: repeated aiserver.v1.EditResult.RelatedInformation related_information = 5;
   */
  relatedInformation: EditResult_RelatedInformation[] = [];

  constructor(data?: PartialMessage<EditResult_Feedback>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.EditResult.Feedback";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "severity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "start_line_number", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "end_line_number", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 5, name: "related_information", kind: "message", T: EditResult_RelatedInformation, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EditResult_Feedback {
    return new EditResult_Feedback().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EditResult_Feedback {
    return new EditResult_Feedback().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EditResult_Feedback {
    return new EditResult_Feedback().fromJsonString(jsonString, options);
  }

  static equals(a: EditResult_Feedback | PlainMessage<EditResult_Feedback> | undefined, b: EditResult_Feedback | PlainMessage<EditResult_Feedback> | undefined): boolean {
    return proto3.util.equals(EditResult_Feedback, a, b);
  }
}

/**
 * TODO: it is possible that this is not the right format for adding tests... but that's ok
 * for now we're just making something that works. we can fix things later
 * if a test with the same name already exists, it is replaced
 *
 * @generated from message aiserver.v1.AddTestParams
 */
export class AddTestParams extends Message<AddTestParams> {
  /**
   * @generated from field: string relative_workspace_path = 1;
   */
  relativeWorkspacePath = "";

  /**
   * the name here is the same name that's used when running the test
   * this is usually either a function/method name, or in the case of javascript, the string inside the it() function
   *
   * @generated from field: string test_name = 2;
   */
  testName = "";

  /**
   * @generated from field: string test_code = 3;
   */
  testCode = "";

  constructor(data?: PartialMessage<AddTestParams>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.AddTestParams";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "test_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "test_code", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AddTestParams {
    return new AddTestParams().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AddTestParams {
    return new AddTestParams().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AddTestParams {
    return new AddTestParams().fromJsonString(jsonString, options);
  }

  static equals(a: AddTestParams | PlainMessage<AddTestParams> | undefined, b: AddTestParams | PlainMessage<AddTestParams> | undefined): boolean {
    return proto3.util.equals(AddTestParams, a, b);
  }
}

/**
 * @generated from message aiserver.v1.AddTestResult
 */
export class AddTestResult extends Message<AddTestResult> {
  /**
   * for now we return linter errors here. in the future we may want to return
   * them in an interrupt since they are technically asynchronous
   *
   * @generated from field: repeated aiserver.v1.AddTestResult.Feedback feedback = 1;
   */
  feedback: AddTestResult_Feedback[] = [];

  constructor(data?: PartialMessage<AddTestResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.AddTestResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "feedback", kind: "message", T: AddTestResult_Feedback, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AddTestResult {
    return new AddTestResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AddTestResult {
    return new AddTestResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AddTestResult {
    return new AddTestResult().fromJsonString(jsonString, options);
  }

  static equals(a: AddTestResult | PlainMessage<AddTestResult> | undefined, b: AddTestResult | PlainMessage<AddTestResult> | undefined): boolean {
    return proto3.util.equals(AddTestResult, a, b);
  }
}

/**
 * @generated from message aiserver.v1.AddTestResult.RelatedInformation
 */
export class AddTestResult_RelatedInformation extends Message<AddTestResult_RelatedInformation> {
  /**
   * @generated from field: string message = 1;
   */
  message = "";

  /**
   * @generated from field: int32 start_line_number = 2;
   */
  startLineNumber = 0;

  /**
   * @generated from field: int32 end_line_number = 3;
   */
  endLineNumber = 0;

  /**
   * @generated from field: string relative_workspace_path = 4;
   */
  relativeWorkspacePath = "";

  constructor(data?: PartialMessage<AddTestResult_RelatedInformation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.AddTestResult.RelatedInformation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "start_line_number", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "end_line_number", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "relative_workspace_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AddTestResult_RelatedInformation {
    return new AddTestResult_RelatedInformation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AddTestResult_RelatedInformation {
    return new AddTestResult_RelatedInformation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AddTestResult_RelatedInformation {
    return new AddTestResult_RelatedInformation().fromJsonString(jsonString, options);
  }

  static equals(a: AddTestResult_RelatedInformation | PlainMessage<AddTestResult_RelatedInformation> | undefined, b: AddTestResult_RelatedInformation | PlainMessage<AddTestResult_RelatedInformation> | undefined): boolean {
    return proto3.util.equals(AddTestResult_RelatedInformation, a, b);
  }
}

/**
 * @generated from message aiserver.v1.AddTestResult.Feedback
 */
export class AddTestResult_Feedback extends Message<AddTestResult_Feedback> {
  /**
   * @generated from field: string message = 1;
   */
  message = "";

  /**
   * @generated from field: string severity = 2;
   */
  severity = "";

  /**
   * @generated from field: int32 start_line_number = 3;
   */
  startLineNumber = 0;

  /**
   * @generated from field: int32 end_line_number = 4;
   */
  endLineNumber = 0;

  /**
   * @generated from field: repeated aiserver.v1.AddTestResult.RelatedInformation related_information = 5;
   */
  relatedInformation: AddTestResult_RelatedInformation[] = [];

  constructor(data?: PartialMessage<AddTestResult_Feedback>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.AddTestResult.Feedback";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "severity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "start_line_number", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "end_line_number", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 5, name: "related_information", kind: "message", T: AddTestResult_RelatedInformation, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AddTestResult_Feedback {
    return new AddTestResult_Feedback().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AddTestResult_Feedback {
    return new AddTestResult_Feedback().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AddTestResult_Feedback {
    return new AddTestResult_Feedback().fromJsonString(jsonString, options);
  }

  static equals(a: AddTestResult_Feedback | PlainMessage<AddTestResult_Feedback> | undefined, b: AddTestResult_Feedback | PlainMessage<AddTestResult_Feedback> | undefined): boolean {
    return proto3.util.equals(AddTestResult_Feedback, a, b);
  }
}

/**
 * TODO: it is possible we need some kind of "project" logic
 * it is also possible running tests should be completely unstructured and the AI just gets full terminal access
 * idk...
 * maybe this structured format is not playing to the LLM's strengths enough
 *
 * @generated from message aiserver.v1.RunTestParams
 */
export class RunTestParams extends Message<RunTestParams> {
  /**
   * @generated from field: string relative_workspace_path = 1;
   */
  relativeWorkspacePath = "";

  /**
   * optionally you can specify a test name to run
   * otherwise all tests in the file will be run
   *
   * @generated from field: optional string test_name = 2;
   */
  testName?: string;

  constructor(data?: PartialMessage<RunTestParams>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.RunTestParams";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "test_name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RunTestParams {
    return new RunTestParams().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RunTestParams {
    return new RunTestParams().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RunTestParams {
    return new RunTestParams().fromJsonString(jsonString, options);
  }

  static equals(a: RunTestParams | PlainMessage<RunTestParams> | undefined, b: RunTestParams | PlainMessage<RunTestParams> | undefined): boolean {
    return proto3.util.equals(RunTestParams, a, b);
  }
}

/**
 * @generated from message aiserver.v1.RunTestResult
 */
export class RunTestResult extends Message<RunTestResult> {
  /**
   * the result from running the test, currently just a raw string
   *
   * @generated from field: string result = 1;
   */
  result = "";

  constructor(data?: PartialMessage<RunTestResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.RunTestResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RunTestResult {
    return new RunTestResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RunTestResult {
    return new RunTestResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RunTestResult {
    return new RunTestResult().fromJsonString(jsonString, options);
  }

  static equals(a: RunTestResult | PlainMessage<RunTestResult> | undefined, b: RunTestResult | PlainMessage<RunTestResult> | undefined): boolean {
    return proto3.util.equals(RunTestResult, a, b);
  }
}

/**
 * @generated from message aiserver.v1.GetTestsParams
 */
export class GetTestsParams extends Message<GetTestsParams> {
  /**
   * @generated from field: string relative_workspace_path = 1;
   */
  relativeWorkspacePath = "";

  constructor(data?: PartialMessage<GetTestsParams>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.GetTestsParams";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetTestsParams {
    return new GetTestsParams().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetTestsParams {
    return new GetTestsParams().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetTestsParams {
    return new GetTestsParams().fromJsonString(jsonString, options);
  }

  static equals(a: GetTestsParams | PlainMessage<GetTestsParams> | undefined, b: GetTestsParams | PlainMessage<GetTestsParams> | undefined): boolean {
    return proto3.util.equals(GetTestsParams, a, b);
  }
}

/**
 * @generated from message aiserver.v1.GetTestsResult
 */
export class GetTestsResult extends Message<GetTestsResult> {
  /**
   * @generated from field: repeated aiserver.v1.GetTestsResult.Test tests = 1;
   */
  tests: GetTestsResult_Test[] = [];

  constructor(data?: PartialMessage<GetTestsResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.GetTestsResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "tests", kind: "message", T: GetTestsResult_Test, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetTestsResult {
    return new GetTestsResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetTestsResult {
    return new GetTestsResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetTestsResult {
    return new GetTestsResult().fromJsonString(jsonString, options);
  }

  static equals(a: GetTestsResult | PlainMessage<GetTestsResult> | undefined, b: GetTestsResult | PlainMessage<GetTestsResult> | undefined): boolean {
    return proto3.util.equals(GetTestsResult, a, b);
  }
}

/**
 * @generated from message aiserver.v1.GetTestsResult.Test
 */
export class GetTestsResult_Test extends Message<GetTestsResult_Test> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: repeated string lines = 2;
   */
  lines: string[] = [];

  constructor(data?: PartialMessage<GetTestsResult_Test>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.GetTestsResult.Test";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "lines", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetTestsResult_Test {
    return new GetTestsResult_Test().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetTestsResult_Test {
    return new GetTestsResult_Test().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetTestsResult_Test {
    return new GetTestsResult_Test().fromJsonString(jsonString, options);
  }

  static equals(a: GetTestsResult_Test | PlainMessage<GetTestsResult_Test> | undefined, b: GetTestsResult_Test | PlainMessage<GetTestsResult_Test> | undefined): boolean {
    return proto3.util.equals(GetTestsResult_Test, a, b);
  }
}

/**
 * @generated from message aiserver.v1.DeleteTestParams
 */
export class DeleteTestParams extends Message<DeleteTestParams> {
  /**
   * @generated from field: string relative_workspace_path = 1;
   */
  relativeWorkspacePath = "";

  /**
   * optionally you can specify a test name to delete
   * if not specified, the entire test file is deleted
   *
   * @generated from field: optional string test_name = 2;
   */
  testName?: string;

  constructor(data?: PartialMessage<DeleteTestParams>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.DeleteTestParams";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "test_name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteTestParams {
    return new DeleteTestParams().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteTestParams {
    return new DeleteTestParams().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteTestParams {
    return new DeleteTestParams().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteTestParams | PlainMessage<DeleteTestParams> | undefined, b: DeleteTestParams | PlainMessage<DeleteTestParams> | undefined): boolean {
    return proto3.util.equals(DeleteTestParams, a, b);
  }
}

/**
 * @generated from message aiserver.v1.DeleteTestResult
 */
export class DeleteTestResult extends Message<DeleteTestResult> {
  constructor(data?: PartialMessage<DeleteTestResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.DeleteTestResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteTestResult {
    return new DeleteTestResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteTestResult {
    return new DeleteTestResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteTestResult {
    return new DeleteTestResult().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteTestResult | PlainMessage<DeleteTestResult> | undefined, b: DeleteTestResult | PlainMessage<DeleteTestResult> | undefined): boolean {
    return proto3.util.equals(DeleteTestResult, a, b);
  }
}

/**
 * @generated from message aiserver.v1.SaveFileParams
 */
export class SaveFileParams extends Message<SaveFileParams> {
  /**
   * @generated from field: string relative_workspace_path = 1;
   */
  relativeWorkspacePath = "";

  constructor(data?: PartialMessage<SaveFileParams>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.SaveFileParams";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SaveFileParams {
    return new SaveFileParams().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SaveFileParams {
    return new SaveFileParams().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SaveFileParams {
    return new SaveFileParams().fromJsonString(jsonString, options);
  }

  static equals(a: SaveFileParams | PlainMessage<SaveFileParams> | undefined, b: SaveFileParams | PlainMessage<SaveFileParams> | undefined): boolean {
    return proto3.util.equals(SaveFileParams, a, b);
  }
}

/**
 * @generated from message aiserver.v1.SaveFileResult
 */
export class SaveFileResult extends Message<SaveFileResult> {
  constructor(data?: PartialMessage<SaveFileResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.SaveFileResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SaveFileResult {
    return new SaveFileResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SaveFileResult {
    return new SaveFileResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SaveFileResult {
    return new SaveFileResult().fromJsonString(jsonString, options);
  }

  static equals(a: SaveFileResult | PlainMessage<SaveFileResult> | undefined, b: SaveFileResult | PlainMessage<SaveFileResult> | undefined): boolean {
    return proto3.util.equals(SaveFileResult, a, b);
  }
}

/**
 * @generated from message aiserver.v1.GetSymbolsParams
 */
export class GetSymbolsParams extends Message<GetSymbolsParams> {
  /**
   * @generated from field: string relative_workspace_path = 1;
   */
  relativeWorkspacePath = "";

  /**
   * we can restrict to a range if we want to, but don't need to
   *
   * @generated from field: optional aiserver.v1.GetSymbolsParams.LineRange line_range = 2;
   */
  lineRange?: GetSymbolsParams_LineRange;

  /**
   * whether to include children of symbols
   * if false, only the top-level symbols are returned, with no children
   * this defaults to false and saves bandwidth if you only care about top-level symbols anyway
   *
   * @generated from field: bool include_children = 3;
   */
  includeChildren = false;

  constructor(data?: PartialMessage<GetSymbolsParams>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.GetSymbolsParams";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "line_range", kind: "message", T: GetSymbolsParams_LineRange, opt: true },
    { no: 3, name: "include_children", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetSymbolsParams {
    return new GetSymbolsParams().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetSymbolsParams {
    return new GetSymbolsParams().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetSymbolsParams {
    return new GetSymbolsParams().fromJsonString(jsonString, options);
  }

  static equals(a: GetSymbolsParams | PlainMessage<GetSymbolsParams> | undefined, b: GetSymbolsParams | PlainMessage<GetSymbolsParams> | undefined): boolean {
    return proto3.util.equals(GetSymbolsParams, a, b);
  }
}

/**
 * @generated from message aiserver.v1.GetSymbolsParams.LineRange
 */
export class GetSymbolsParams_LineRange extends Message<GetSymbolsParams_LineRange> {
  /**
   * both 1-indexed
   *
   * @generated from field: int32 start_line_number = 1;
   */
  startLineNumber = 0;

  /**
   * @generated from field: int32 end_line_number_inclusive = 2;
   */
  endLineNumberInclusive = 0;

  constructor(data?: PartialMessage<GetSymbolsParams_LineRange>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.GetSymbolsParams.LineRange";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "start_line_number", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "end_line_number_inclusive", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetSymbolsParams_LineRange {
    return new GetSymbolsParams_LineRange().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetSymbolsParams_LineRange {
    return new GetSymbolsParams_LineRange().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetSymbolsParams_LineRange {
    return new GetSymbolsParams_LineRange().fromJsonString(jsonString, options);
  }

  static equals(a: GetSymbolsParams_LineRange | PlainMessage<GetSymbolsParams_LineRange> | undefined, b: GetSymbolsParams_LineRange | PlainMessage<GetSymbolsParams_LineRange> | undefined): boolean {
    return proto3.util.equals(GetSymbolsParams_LineRange, a, b);
  }
}

/**
 * @generated from message aiserver.v1.DocumentSymbol
 */
export class DocumentSymbol extends Message<DocumentSymbol> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: string detail = 2;
   */
  detail = "";

  /**
   * @generated from field: aiserver.v1.DocumentSymbol.SymbolKind kind = 3;
   */
  kind = DocumentSymbol_SymbolKind.UNSPECIFIED;

  /**
   * @generated from field: string container_name = 5;
   */
  containerName = "";

  /**
   * @generated from field: aiserver.v1.DocumentSymbol.Range range = 6;
   */
  range?: DocumentSymbol_Range;

  /**
   * @generated from field: aiserver.v1.DocumentSymbol.Range selection_range = 7;
   */
  selectionRange?: DocumentSymbol_Range;

  /**
   * @generated from field: repeated aiserver.v1.DocumentSymbol children = 8;
   */
  children: DocumentSymbol[] = [];

  constructor(data?: PartialMessage<DocumentSymbol>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.DocumentSymbol";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "detail", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "kind", kind: "enum", T: proto3.getEnumType(DocumentSymbol_SymbolKind) },
    { no: 5, name: "container_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "range", kind: "message", T: DocumentSymbol_Range },
    { no: 7, name: "selection_range", kind: "message", T: DocumentSymbol_Range },
    { no: 8, name: "children", kind: "message", T: DocumentSymbol, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DocumentSymbol {
    return new DocumentSymbol().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DocumentSymbol {
    return new DocumentSymbol().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DocumentSymbol {
    return new DocumentSymbol().fromJsonString(jsonString, options);
  }

  static equals(a: DocumentSymbol | PlainMessage<DocumentSymbol> | undefined, b: DocumentSymbol | PlainMessage<DocumentSymbol> | undefined): boolean {
    return proto3.util.equals(DocumentSymbol, a, b);
  }
}

/**
 * @generated from enum aiserver.v1.DocumentSymbol.SymbolKind
 */
export enum DocumentSymbol_SymbolKind {
  /**
   * @generated from enum value: SYMBOL_KIND_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: SYMBOL_KIND_FILE = 1;
   */
  FILE = 1,

  /**
   * @generated from enum value: SYMBOL_KIND_MODULE = 2;
   */
  MODULE = 2,

  /**
   * @generated from enum value: SYMBOL_KIND_NAMESPACE = 3;
   */
  NAMESPACE = 3,

  /**
   * @generated from enum value: SYMBOL_KIND_PACKAGE = 4;
   */
  PACKAGE = 4,

  /**
   * @generated from enum value: SYMBOL_KIND_CLASS = 5;
   */
  CLASS = 5,

  /**
   * @generated from enum value: SYMBOL_KIND_METHOD = 6;
   */
  METHOD = 6,

  /**
   * @generated from enum value: SYMBOL_KIND_PROPERTY = 7;
   */
  PROPERTY = 7,

  /**
   * @generated from enum value: SYMBOL_KIND_FIELD = 8;
   */
  FIELD = 8,

  /**
   * @generated from enum value: SYMBOL_KIND_CONSTRUCTOR = 9;
   */
  CONSTRUCTOR = 9,

  /**
   * @generated from enum value: SYMBOL_KIND_ENUM = 10;
   */
  ENUM = 10,

  /**
   * @generated from enum value: SYMBOL_KIND_INTERFACE = 11;
   */
  INTERFACE = 11,

  /**
   * @generated from enum value: SYMBOL_KIND_FUNCTION = 12;
   */
  FUNCTION = 12,

  /**
   * @generated from enum value: SYMBOL_KIND_VARIABLE = 13;
   */
  VARIABLE = 13,

  /**
   * @generated from enum value: SYMBOL_KIND_CONSTANT = 14;
   */
  CONSTANT = 14,

  /**
   * @generated from enum value: SYMBOL_KIND_STRING = 15;
   */
  STRING = 15,

  /**
   * @generated from enum value: SYMBOL_KIND_NUMBER = 16;
   */
  NUMBER = 16,

  /**
   * @generated from enum value: SYMBOL_KIND_BOOLEAN = 17;
   */
  BOOLEAN = 17,

  /**
   * @generated from enum value: SYMBOL_KIND_ARRAY = 18;
   */
  ARRAY = 18,

  /**
   * @generated from enum value: SYMBOL_KIND_OBJECT = 19;
   */
  OBJECT = 19,

  /**
   * @generated from enum value: SYMBOL_KIND_KEY = 20;
   */
  KEY = 20,

  /**
   * @generated from enum value: SYMBOL_KIND_NULL = 21;
   */
  NULL = 21,

  /**
   * @generated from enum value: SYMBOL_KIND_ENUM_MEMBER = 22;
   */
  ENUM_MEMBER = 22,

  /**
   * @generated from enum value: SYMBOL_KIND_STRUCT = 23;
   */
  STRUCT = 23,

  /**
   * @generated from enum value: SYMBOL_KIND_EVENT = 24;
   */
  EVENT = 24,

  /**
   * @generated from enum value: SYMBOL_KIND_OPERATOR = 25;
   */
  OPERATOR = 25,

  /**
   * @generated from enum value: SYMBOL_KIND_TYPE_PARAMETER = 26;
   */
  TYPE_PARAMETER = 26,
}
// Retrieve enum metadata with: proto3.getEnumType(DocumentSymbol_SymbolKind)
proto3.util.setEnumType(DocumentSymbol_SymbolKind, "aiserver.v1.DocumentSymbol.SymbolKind", [
  { no: 0, name: "SYMBOL_KIND_UNSPECIFIED" },
  { no: 1, name: "SYMBOL_KIND_FILE" },
  { no: 2, name: "SYMBOL_KIND_MODULE" },
  { no: 3, name: "SYMBOL_KIND_NAMESPACE" },
  { no: 4, name: "SYMBOL_KIND_PACKAGE" },
  { no: 5, name: "SYMBOL_KIND_CLASS" },
  { no: 6, name: "SYMBOL_KIND_METHOD" },
  { no: 7, name: "SYMBOL_KIND_PROPERTY" },
  { no: 8, name: "SYMBOL_KIND_FIELD" },
  { no: 9, name: "SYMBOL_KIND_CONSTRUCTOR" },
  { no: 10, name: "SYMBOL_KIND_ENUM" },
  { no: 11, name: "SYMBOL_KIND_INTERFACE" },
  { no: 12, name: "SYMBOL_KIND_FUNCTION" },
  { no: 13, name: "SYMBOL_KIND_VARIABLE" },
  { no: 14, name: "SYMBOL_KIND_CONSTANT" },
  { no: 15, name: "SYMBOL_KIND_STRING" },
  { no: 16, name: "SYMBOL_KIND_NUMBER" },
  { no: 17, name: "SYMBOL_KIND_BOOLEAN" },
  { no: 18, name: "SYMBOL_KIND_ARRAY" },
  { no: 19, name: "SYMBOL_KIND_OBJECT" },
  { no: 20, name: "SYMBOL_KIND_KEY" },
  { no: 21, name: "SYMBOL_KIND_NULL" },
  { no: 22, name: "SYMBOL_KIND_ENUM_MEMBER" },
  { no: 23, name: "SYMBOL_KIND_STRUCT" },
  { no: 24, name: "SYMBOL_KIND_EVENT" },
  { no: 25, name: "SYMBOL_KIND_OPERATOR" },
  { no: 26, name: "SYMBOL_KIND_TYPE_PARAMETER" },
]);

/**
 * everything here is 1-indexed
 *
 * @generated from message aiserver.v1.DocumentSymbol.Range
 */
export class DocumentSymbol_Range extends Message<DocumentSymbol_Range> {
  /**
   * @generated from field: int32 start_line_number = 1;
   */
  startLineNumber = 0;

  /**
   * @generated from field: int32 start_column = 2;
   */
  startColumn = 0;

  /**
   * @generated from field: int32 end_line_number = 3;
   */
  endLineNumber = 0;

  /**
   * @generated from field: int32 end_column = 4;
   */
  endColumn = 0;

  constructor(data?: PartialMessage<DocumentSymbol_Range>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.DocumentSymbol.Range";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "start_line_number", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "start_column", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "end_line_number", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "end_column", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DocumentSymbol_Range {
    return new DocumentSymbol_Range().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DocumentSymbol_Range {
    return new DocumentSymbol_Range().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DocumentSymbol_Range {
    return new DocumentSymbol_Range().fromJsonString(jsonString, options);
  }

  static equals(a: DocumentSymbol_Range | PlainMessage<DocumentSymbol_Range> | undefined, b: DocumentSymbol_Range | PlainMessage<DocumentSymbol_Range> | undefined): boolean {
    return proto3.util.equals(DocumentSymbol_Range, a, b);
  }
}

/**
 * @generated from message aiserver.v1.GetSymbolsResult
 */
export class GetSymbolsResult extends Message<GetSymbolsResult> {
  /**
   * @generated from field: repeated aiserver.v1.DocumentSymbol symbols = 1;
   */
  symbols: DocumentSymbol[] = [];

  constructor(data?: PartialMessage<GetSymbolsResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.GetSymbolsResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "symbols", kind: "message", T: DocumentSymbol, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetSymbolsResult {
    return new GetSymbolsResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetSymbolsResult {
    return new GetSymbolsResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetSymbolsResult {
    return new GetSymbolsResult().fromJsonString(jsonString, options);
  }

  static equals(a: GetSymbolsResult | PlainMessage<GetSymbolsResult> | undefined, b: GetSymbolsResult | PlainMessage<GetSymbolsResult> | undefined): boolean {
    return proto3.util.equals(GetSymbolsResult, a, b);
  }
}

