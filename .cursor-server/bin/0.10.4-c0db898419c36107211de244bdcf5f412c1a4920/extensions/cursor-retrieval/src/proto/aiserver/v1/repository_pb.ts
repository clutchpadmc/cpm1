// @generated by protoc-gen-es v1.2.1 with parameter "target=ts"
// @generated from file aiserver/v1/repository.proto (package aiserver.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { CodeBlock, File, ModelDetails } from './utils_pb';
import { IndexFileData_NodeData, ReflectionData } from './symbolic_context_pb';

/**
 * @generated from enum aiserver.v1.ChunkingStrategy
 */
export enum ChunkingStrategy {
  /**
   * @generated from enum value: CHUNKING_STRATEGY_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: CHUNKING_STRATEGY_DEFAULT = 1;
   */
  DEFAULT = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(ChunkingStrategy)
proto3.util.setEnumType(ChunkingStrategy, "aiserver.v1.ChunkingStrategy", [
  { no: 0, name: "CHUNKING_STRATEGY_UNSPECIFIED" },
  { no: 1, name: "CHUNKING_STRATEGY_DEFAULT" },
]);

/**
 * @generated from enum aiserver.v1.RerankerAlgorithm
 */
export enum RerankerAlgorithm {
  /**
   * if unspecified, then we use whatever is the default algorithm
   *
   * @generated from enum value: RERANKER_ALGORITHM_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * lulea = 3.5-chain-of-thought
   *
   * @generated from enum value: RERANKER_ALGORITHM_LULEA = 1;
   */
  LULEA = 1,

  /**
   * umea = 3.5 without chain-of-thought
   *
   * @generated from enum value: RERANKER_ALGORITHM_UMEA = 2;
   */
  UMEA = 2,

  /**
   * @generated from enum value: RERANKER_ALGORITHM_NONE = 3;
   */
  NONE = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(RerankerAlgorithm)
proto3.util.setEnumType(RerankerAlgorithm, "aiserver.v1.RerankerAlgorithm", [
  { no: 0, name: "RERANKER_ALGORITHM_UNSPECIFIED" },
  { no: 1, name: "RERANKER_ALGORITHM_LULEA" },
  { no: 2, name: "RERANKER_ALGORITHM_UMEA" },
  { no: 3, name: "RERANKER_ALGORITHM_NONE" },
]);

/**
 * it also sends a path to the top that it should update
 *
 * @generated from message aiserver.v1.PartialPathItem
 */
export class PartialPathItem extends Message<PartialPathItem> {
  /**
   * @generated from field: string relative_path = 1;
   */
  relativePath = "";

  /**
   * @generated from field: string hash_of_node = 2;
   */
  hashOfNode = "";

  constructor(data?: PartialMessage<PartialPathItem>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.PartialPathItem";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "relative_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "hash_of_node", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PartialPathItem {
    return new PartialPathItem().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PartialPathItem {
    return new PartialPathItem().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PartialPathItem {
    return new PartialPathItem().fromJsonString(jsonString, options);
  }

  static equals(a: PartialPathItem | PlainMessage<PartialPathItem> | undefined, b: PartialPathItem | PlainMessage<PartialPathItem> | undefined): boolean {
    return proto3.util.equals(PartialPathItem, a, b);
  }
}

/**
 * @generated from message aiserver.v1.FastRepoInitHandshakeRequest
 */
export class FastRepoInitHandshakeRequest extends Message<FastRepoInitHandshakeRequest> {
  /**
   * @generated from field: aiserver.v1.RepositoryInfo repository = 1;
   */
  repository?: RepositoryInfo;

  /**
   * @generated from field: string root_hash = 2;
   */
  rootHash = "";

  constructor(data?: PartialMessage<FastRepoInitHandshakeRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.FastRepoInitHandshakeRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "repository", kind: "message", T: RepositoryInfo },
    { no: 2, name: "root_hash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FastRepoInitHandshakeRequest {
    return new FastRepoInitHandshakeRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FastRepoInitHandshakeRequest {
    return new FastRepoInitHandshakeRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FastRepoInitHandshakeRequest {
    return new FastRepoInitHandshakeRequest().fromJsonString(jsonString, options);
  }

  static equals(a: FastRepoInitHandshakeRequest | PlainMessage<FastRepoInitHandshakeRequest> | undefined, b: FastRepoInitHandshakeRequest | PlainMessage<FastRepoInitHandshakeRequest> | undefined): boolean {
    return proto3.util.equals(FastRepoInitHandshakeRequest, a, b);
  }
}

/**
 * @generated from message aiserver.v1.FastRepoInitHandshakeResponse
 */
export class FastRepoInitHandshakeResponse extends Message<FastRepoInitHandshakeResponse> {
  /**
   * @generated from field: aiserver.v1.FastRepoInitHandshakeResponse.Status status = 1;
   */
  status = FastRepoInitHandshakeResponse_Status.UNSPECIFIED;

  constructor(data?: PartialMessage<FastRepoInitHandshakeResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.FastRepoInitHandshakeResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "status", kind: "enum", T: proto3.getEnumType(FastRepoInitHandshakeResponse_Status) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FastRepoInitHandshakeResponse {
    return new FastRepoInitHandshakeResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FastRepoInitHandshakeResponse {
    return new FastRepoInitHandshakeResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FastRepoInitHandshakeResponse {
    return new FastRepoInitHandshakeResponse().fromJsonString(jsonString, options);
  }

  static equals(a: FastRepoInitHandshakeResponse | PlainMessage<FastRepoInitHandshakeResponse> | undefined, b: FastRepoInitHandshakeResponse | PlainMessage<FastRepoInitHandshakeResponse> | undefined): boolean {
    return proto3.util.equals(FastRepoInitHandshakeResponse, a, b);
  }
}

/**
 * @generated from enum aiserver.v1.FastRepoInitHandshakeResponse.Status
 */
export enum FastRepoInitHandshakeResponse_Status {
  /**
   * @generated from enum value: STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: STATUS_UP_TO_DATE = 1;
   */
  UP_TO_DATE = 1,

  /**
   * @generated from enum value: STATUS_OUT_OF_SYNC = 2;
   */
  OUT_OF_SYNC = 2,

  /**
   * @generated from enum value: STATUS_FAILURE = 3;
   */
  FAILURE = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(FastRepoInitHandshakeResponse_Status)
proto3.util.setEnumType(FastRepoInitHandshakeResponse_Status, "aiserver.v1.FastRepoInitHandshakeResponse.Status", [
  { no: 0, name: "STATUS_UNSPECIFIED" },
  { no: 1, name: "STATUS_UP_TO_DATE" },
  { no: 2, name: "STATUS_OUT_OF_SYNC" },
  { no: 3, name: "STATUS_FAILURE" },
]);

/**
 * @generated from message aiserver.v1.SyncMerkleSubtreeRequest
 */
export class SyncMerkleSubtreeRequest extends Message<SyncMerkleSubtreeRequest> {
  /**
   * @generated from field: aiserver.v1.RepositoryInfo repository = 1;
   */
  repository?: RepositoryInfo;

  /**
   * @generated from field: aiserver.v1.PartialPathItem local_partial_path = 2;
   */
  localPartialPath?: PartialPathItem;

  constructor(data?: PartialMessage<SyncMerkleSubtreeRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.SyncMerkleSubtreeRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "repository", kind: "message", T: RepositoryInfo },
    { no: 2, name: "local_partial_path", kind: "message", T: PartialPathItem },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SyncMerkleSubtreeRequest {
    return new SyncMerkleSubtreeRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SyncMerkleSubtreeRequest {
    return new SyncMerkleSubtreeRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SyncMerkleSubtreeRequest {
    return new SyncMerkleSubtreeRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SyncMerkleSubtreeRequest | PlainMessage<SyncMerkleSubtreeRequest> | undefined, b: SyncMerkleSubtreeRequest | PlainMessage<SyncMerkleSubtreeRequest> | undefined): boolean {
    return proto3.util.equals(SyncMerkleSubtreeRequest, a, b);
  }
}

/**
 * @generated from message aiserver.v1.SyncMerkleSubtreeResponse
 */
export class SyncMerkleSubtreeResponse extends Message<SyncMerkleSubtreeResponse> {
  /**
   * @generated from oneof aiserver.v1.SyncMerkleSubtreeResponse.result
   */
  result: {
    /**
     * @generated from field: bool match = 1;
     */
    value: boolean;
    case: "match";
  } | {
    /**
     * @generated from field: aiserver.v1.SyncMerkleSubtreeResponse.Mismatch mismatch = 2;
     */
    value: SyncMerkleSubtreeResponse_Mismatch;
    case: "mismatch";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<SyncMerkleSubtreeResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.SyncMerkleSubtreeResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "match", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "result" },
    { no: 2, name: "mismatch", kind: "message", T: SyncMerkleSubtreeResponse_Mismatch, oneof: "result" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SyncMerkleSubtreeResponse {
    return new SyncMerkleSubtreeResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SyncMerkleSubtreeResponse {
    return new SyncMerkleSubtreeResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SyncMerkleSubtreeResponse {
    return new SyncMerkleSubtreeResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SyncMerkleSubtreeResponse | PlainMessage<SyncMerkleSubtreeResponse> | undefined, b: SyncMerkleSubtreeResponse | PlainMessage<SyncMerkleSubtreeResponse> | undefined): boolean {
    return proto3.util.equals(SyncMerkleSubtreeResponse, a, b);
  }
}

/**
 * @generated from message aiserver.v1.SyncMerkleSubtreeResponse.Mismatch
 */
export class SyncMerkleSubtreeResponse_Mismatch extends Message<SyncMerkleSubtreeResponse_Mismatch> {
  /**
   * @generated from field: repeated aiserver.v1.PartialPathItem children = 1;
   */
  children: PartialPathItem[] = [];

  constructor(data?: PartialMessage<SyncMerkleSubtreeResponse_Mismatch>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.SyncMerkleSubtreeResponse.Mismatch";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "children", kind: "message", T: PartialPathItem, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SyncMerkleSubtreeResponse_Mismatch {
    return new SyncMerkleSubtreeResponse_Mismatch().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SyncMerkleSubtreeResponse_Mismatch {
    return new SyncMerkleSubtreeResponse_Mismatch().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SyncMerkleSubtreeResponse_Mismatch {
    return new SyncMerkleSubtreeResponse_Mismatch().fromJsonString(jsonString, options);
  }

  static equals(a: SyncMerkleSubtreeResponse_Mismatch | PlainMessage<SyncMerkleSubtreeResponse_Mismatch> | undefined, b: SyncMerkleSubtreeResponse_Mismatch | PlainMessage<SyncMerkleSubtreeResponse_Mismatch> | undefined): boolean {
    return proto3.util.equals(SyncMerkleSubtreeResponse_Mismatch, a, b);
  }
}

/**
 * @generated from message aiserver.v1.FastUpdateFileRequest
 */
export class FastUpdateFileRequest extends Message<FastUpdateFileRequest> {
  /**
   * @generated from field: aiserver.v1.RepositoryInfo repository = 1;
   */
  repository?: RepositoryInfo;

  /**
   * @generated from field: aiserver.v1.File file = 2;
   */
  file?: File;

  /**
   * @generated from field: string hash = 3;
   */
  hash = "";

  /**
   * INVARIANT:
   * 1. the first item is the parent directory of the file.
   * 2. the last item is the root of the merkle tree
   * 3, each item is the parent of the previous item
   *
   * @generated from field: repeated aiserver.v1.PartialPathItem partial_path = 4;
   */
  partialPath: PartialPathItem[] = [];

  /**
   * @generated from field: aiserver.v1.FastUpdateFileRequest.UpdateType update_type = 5;
   */
  updateType = FastUpdateFileRequest_UpdateType.UNSPECIFIED;

  constructor(data?: PartialMessage<FastUpdateFileRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.FastUpdateFileRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "repository", kind: "message", T: RepositoryInfo },
    { no: 2, name: "file", kind: "message", T: File },
    { no: 3, name: "hash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "partial_path", kind: "message", T: PartialPathItem, repeated: true },
    { no: 5, name: "update_type", kind: "enum", T: proto3.getEnumType(FastUpdateFileRequest_UpdateType) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FastUpdateFileRequest {
    return new FastUpdateFileRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FastUpdateFileRequest {
    return new FastUpdateFileRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FastUpdateFileRequest {
    return new FastUpdateFileRequest().fromJsonString(jsonString, options);
  }

  static equals(a: FastUpdateFileRequest | PlainMessage<FastUpdateFileRequest> | undefined, b: FastUpdateFileRequest | PlainMessage<FastUpdateFileRequest> | undefined): boolean {
    return proto3.util.equals(FastUpdateFileRequest, a, b);
  }
}

/**
 * @generated from enum aiserver.v1.FastUpdateFileRequest.UpdateType
 */
export enum FastUpdateFileRequest_UpdateType {
  /**
   * @generated from enum value: UPDATE_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: UPDATE_TYPE_ADD = 1;
   */
  ADD = 1,

  /**
   * @generated from enum value: UPDATE_TYPE_DELETE = 2;
   */
  DELETE = 2,

  /**
   * @generated from enum value: UPDATE_TYPE_MODIFY = 3;
   */
  MODIFY = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(FastUpdateFileRequest_UpdateType)
proto3.util.setEnumType(FastUpdateFileRequest_UpdateType, "aiserver.v1.FastUpdateFileRequest.UpdateType", [
  { no: 0, name: "UPDATE_TYPE_UNSPECIFIED" },
  { no: 1, name: "UPDATE_TYPE_ADD" },
  { no: 2, name: "UPDATE_TYPE_DELETE" },
  { no: 3, name: "UPDATE_TYPE_MODIFY" },
]);

/**
 * @generated from message aiserver.v1.FastUpdateFileResponse
 */
export class FastUpdateFileResponse extends Message<FastUpdateFileResponse> {
  /**
   * @generated from field: aiserver.v1.FastUpdateFileResponse.Status status = 1;
   */
  status = FastUpdateFileResponse_Status.UNSPECIFIED;

  constructor(data?: PartialMessage<FastUpdateFileResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.FastUpdateFileResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "status", kind: "enum", T: proto3.getEnumType(FastUpdateFileResponse_Status) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FastUpdateFileResponse {
    return new FastUpdateFileResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FastUpdateFileResponse {
    return new FastUpdateFileResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FastUpdateFileResponse {
    return new FastUpdateFileResponse().fromJsonString(jsonString, options);
  }

  static equals(a: FastUpdateFileResponse | PlainMessage<FastUpdateFileResponse> | undefined, b: FastUpdateFileResponse | PlainMessage<FastUpdateFileResponse> | undefined): boolean {
    return proto3.util.equals(FastUpdateFileResponse, a, b);
  }
}

/**
 * @generated from enum aiserver.v1.FastUpdateFileResponse.Status
 */
export enum FastUpdateFileResponse_Status {
  /**
   * @generated from enum value: STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: STATUS_SUCCESS = 1;
   */
  SUCCESS = 1,

  /**
   * @generated from enum value: STATUS_FAILURE = 2;
   */
  FAILURE = 2,

  /**
   * @generated from enum value: STATUS_EXPECTED_FAILURE = 3;
   */
  EXPECTED_FAILURE = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(FastUpdateFileResponse_Status)
proto3.util.setEnumType(FastUpdateFileResponse_Status, "aiserver.v1.FastUpdateFileResponse.Status", [
  { no: 0, name: "STATUS_UNSPECIFIED" },
  { no: 1, name: "STATUS_SUCCESS" },
  { no: 2, name: "STATUS_FAILURE" },
  { no: 3, name: "STATUS_EXPECTED_FAILURE" },
]);

/**
 * @generated from message aiserver.v1.GetUploadLimitsRequest
 */
export class GetUploadLimitsRequest extends Message<GetUploadLimitsRequest> {
  /**
   * @generated from field: optional aiserver.v1.RepositoryInfo repository = 1;
   */
  repository?: RepositoryInfo;

  constructor(data?: PartialMessage<GetUploadLimitsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.GetUploadLimitsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "repository", kind: "message", T: RepositoryInfo, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetUploadLimitsRequest {
    return new GetUploadLimitsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetUploadLimitsRequest {
    return new GetUploadLimitsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetUploadLimitsRequest {
    return new GetUploadLimitsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetUploadLimitsRequest | PlainMessage<GetUploadLimitsRequest> | undefined, b: GetUploadLimitsRequest | PlainMessage<GetUploadLimitsRequest> | undefined): boolean {
    return proto3.util.equals(GetUploadLimitsRequest, a, b);
  }
}

/**
 * @generated from message aiserver.v1.GetUploadLimitsResponse
 */
export class GetUploadLimitsResponse extends Message<GetUploadLimitsResponse> {
  /**
   * @generated from field: int32 soft_limit = 1;
   */
  softLimit = 0;

  /**
   * @generated from field: int32 hard_limit = 2;
   */
  hardLimit = 0;

  constructor(data?: PartialMessage<GetUploadLimitsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.GetUploadLimitsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "soft_limit", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "hard_limit", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetUploadLimitsResponse {
    return new GetUploadLimitsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetUploadLimitsResponse {
    return new GetUploadLimitsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetUploadLimitsResponse {
    return new GetUploadLimitsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetUploadLimitsResponse | PlainMessage<GetUploadLimitsResponse> | undefined, b: GetUploadLimitsResponse | PlainMessage<GetUploadLimitsResponse> | undefined): boolean {
    return proto3.util.equals(GetUploadLimitsResponse, a, b);
  }
}

/**
 * @generated from message aiserver.v1.GetNumFilesToSendRequest
 */
export class GetNumFilesToSendRequest extends Message<GetNumFilesToSendRequest> {
  /**
   * includes the number of files in the repo to give a rough estimate of size.
   *
   * @generated from field: aiserver.v1.RepositoryInfo repository = 1;
   */
  repository?: RepositoryInfo;

  constructor(data?: PartialMessage<GetNumFilesToSendRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.GetNumFilesToSendRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "repository", kind: "message", T: RepositoryInfo },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetNumFilesToSendRequest {
    return new GetNumFilesToSendRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetNumFilesToSendRequest {
    return new GetNumFilesToSendRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetNumFilesToSendRequest {
    return new GetNumFilesToSendRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetNumFilesToSendRequest | PlainMessage<GetNumFilesToSendRequest> | undefined, b: GetNumFilesToSendRequest | PlainMessage<GetNumFilesToSendRequest> | undefined): boolean {
    return proto3.util.equals(GetNumFilesToSendRequest, a, b);
  }
}

/**
 * @generated from message aiserver.v1.GetNumFilesToSendResponse
 */
export class GetNumFilesToSendResponse extends Message<GetNumFilesToSendResponse> {
  /**
   * @generated from field: int32 num_files = 1;
   */
  numFiles = 0;

  constructor(data?: PartialMessage<GetNumFilesToSendResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.GetNumFilesToSendResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "num_files", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetNumFilesToSendResponse {
    return new GetNumFilesToSendResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetNumFilesToSendResponse {
    return new GetNumFilesToSendResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetNumFilesToSendResponse {
    return new GetNumFilesToSendResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetNumFilesToSendResponse | PlainMessage<GetNumFilesToSendResponse> | undefined, b: GetNumFilesToSendResponse | PlainMessage<GetNumFilesToSendResponse> | undefined): boolean {
    return proto3.util.equals(GetNumFilesToSendResponse, a, b);
  }
}

/**
 * @generated from message aiserver.v1.GetAvailableChunkingStrategiesRequest
 */
export class GetAvailableChunkingStrategiesRequest extends Message<GetAvailableChunkingStrategiesRequest> {
  /**
   * @generated from field: aiserver.v1.RepositoryInfo repository = 1;
   */
  repository?: RepositoryInfo;

  constructor(data?: PartialMessage<GetAvailableChunkingStrategiesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.GetAvailableChunkingStrategiesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "repository", kind: "message", T: RepositoryInfo },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAvailableChunkingStrategiesRequest {
    return new GetAvailableChunkingStrategiesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAvailableChunkingStrategiesRequest {
    return new GetAvailableChunkingStrategiesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAvailableChunkingStrategiesRequest {
    return new GetAvailableChunkingStrategiesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetAvailableChunkingStrategiesRequest | PlainMessage<GetAvailableChunkingStrategiesRequest> | undefined, b: GetAvailableChunkingStrategiesRequest | PlainMessage<GetAvailableChunkingStrategiesRequest> | undefined): boolean {
    return proto3.util.equals(GetAvailableChunkingStrategiesRequest, a, b);
  }
}

/**
 * @generated from message aiserver.v1.GetAvailableChunkingStrategiesResponse
 */
export class GetAvailableChunkingStrategiesResponse extends Message<GetAvailableChunkingStrategiesResponse> {
  /**
   * @generated from field: repeated aiserver.v1.ChunkingStrategy chunking_strategies = 1;
   */
  chunkingStrategies: ChunkingStrategy[] = [];

  constructor(data?: PartialMessage<GetAvailableChunkingStrategiesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.GetAvailableChunkingStrategiesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chunking_strategies", kind: "enum", T: proto3.getEnumType(ChunkingStrategy), repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAvailableChunkingStrategiesResponse {
    return new GetAvailableChunkingStrategiesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAvailableChunkingStrategiesResponse {
    return new GetAvailableChunkingStrategiesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAvailableChunkingStrategiesResponse {
    return new GetAvailableChunkingStrategiesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetAvailableChunkingStrategiesResponse | PlainMessage<GetAvailableChunkingStrategiesResponse> | undefined, b: GetAvailableChunkingStrategiesResponse | PlainMessage<GetAvailableChunkingStrategiesResponse> | undefined): boolean {
    return proto3.util.equals(GetAvailableChunkingStrategiesResponse, a, b);
  }
}

/**
 * @generated from message aiserver.v1.GetEmbeddingsRequest
 */
export class GetEmbeddingsRequest extends Message<GetEmbeddingsRequest> {
  /**
   * @generated from field: repeated string texts = 1;
   */
  texts: string[] = [];

  constructor(data?: PartialMessage<GetEmbeddingsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.GetEmbeddingsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "texts", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetEmbeddingsRequest {
    return new GetEmbeddingsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetEmbeddingsRequest {
    return new GetEmbeddingsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetEmbeddingsRequest {
    return new GetEmbeddingsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetEmbeddingsRequest | PlainMessage<GetEmbeddingsRequest> | undefined, b: GetEmbeddingsRequest | PlainMessage<GetEmbeddingsRequest> | undefined): boolean {
    return proto3.util.equals(GetEmbeddingsRequest, a, b);
  }
}

/**
 * @generated from message aiserver.v1.GetEmbeddingsResponse
 */
export class GetEmbeddingsResponse extends Message<GetEmbeddingsResponse> {
  /**
   * @generated from field: repeated aiserver.v1.GetEmbeddingsResponse.Embedding embeddings = 2;
   */
  embeddings: GetEmbeddingsResponse_Embedding[] = [];

  constructor(data?: PartialMessage<GetEmbeddingsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.GetEmbeddingsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "embeddings", kind: "message", T: GetEmbeddingsResponse_Embedding, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetEmbeddingsResponse {
    return new GetEmbeddingsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetEmbeddingsResponse {
    return new GetEmbeddingsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetEmbeddingsResponse {
    return new GetEmbeddingsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetEmbeddingsResponse | PlainMessage<GetEmbeddingsResponse> | undefined, b: GetEmbeddingsResponse | PlainMessage<GetEmbeddingsResponse> | undefined): boolean {
    return proto3.util.equals(GetEmbeddingsResponse, a, b);
  }
}

/**
 * @generated from message aiserver.v1.GetEmbeddingsResponse.Embedding
 */
export class GetEmbeddingsResponse_Embedding extends Message<GetEmbeddingsResponse_Embedding> {
  /**
   * @generated from field: repeated float embedding = 1;
   */
  embedding: number[] = [];

  constructor(data?: PartialMessage<GetEmbeddingsResponse_Embedding>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.GetEmbeddingsResponse.Embedding";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "embedding", kind: "scalar", T: 2 /* ScalarType.FLOAT */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetEmbeddingsResponse_Embedding {
    return new GetEmbeddingsResponse_Embedding().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetEmbeddingsResponse_Embedding {
    return new GetEmbeddingsResponse_Embedding().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetEmbeddingsResponse_Embedding {
    return new GetEmbeddingsResponse_Embedding().fromJsonString(jsonString, options);
  }

  static equals(a: GetEmbeddingsResponse_Embedding | PlainMessage<GetEmbeddingsResponse_Embedding> | undefined, b: GetEmbeddingsResponse_Embedding | PlainMessage<GetEmbeddingsResponse_Embedding> | undefined): boolean {
    return proto3.util.equals(GetEmbeddingsResponse_Embedding, a, b);
  }
}

/**
 * @generated from message aiserver.v1.AdminRemoveRepositoryRequest
 */
export class AdminRemoveRepositoryRequest extends Message<AdminRemoveRepositoryRequest> {
  /**
   * @generated from field: int32 codebase_id = 1;
   */
  codebaseId = 0;

  constructor(data?: PartialMessage<AdminRemoveRepositoryRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.AdminRemoveRepositoryRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "codebase_id", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AdminRemoveRepositoryRequest {
    return new AdminRemoveRepositoryRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AdminRemoveRepositoryRequest {
    return new AdminRemoveRepositoryRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AdminRemoveRepositoryRequest {
    return new AdminRemoveRepositoryRequest().fromJsonString(jsonString, options);
  }

  static equals(a: AdminRemoveRepositoryRequest | PlainMessage<AdminRemoveRepositoryRequest> | undefined, b: AdminRemoveRepositoryRequest | PlainMessage<AdminRemoveRepositoryRequest> | undefined): boolean {
    return proto3.util.equals(AdminRemoveRepositoryRequest, a, b);
  }
}

/**
 * @generated from message aiserver.v1.AdminRemoveRepositoryResponse
 */
export class AdminRemoveRepositoryResponse extends Message<AdminRemoveRepositoryResponse> {
  constructor(data?: PartialMessage<AdminRemoveRepositoryResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.AdminRemoveRepositoryResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AdminRemoveRepositoryResponse {
    return new AdminRemoveRepositoryResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AdminRemoveRepositoryResponse {
    return new AdminRemoveRepositoryResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AdminRemoveRepositoryResponse {
    return new AdminRemoveRepositoryResponse().fromJsonString(jsonString, options);
  }

  static equals(a: AdminRemoveRepositoryResponse | PlainMessage<AdminRemoveRepositoryResponse> | undefined, b: AdminRemoveRepositoryResponse | PlainMessage<AdminRemoveRepositoryResponse> | undefined): boolean {
    return proto3.util.equals(AdminRemoveRepositoryResponse, a, b);
  }
}

/**
 * @generated from message aiserver.v1.SyncRepositoryRequest
 */
export class SyncRepositoryRequest extends Message<SyncRepositoryRequest> {
  /**
   * @generated from field: int32 codebase_id = 1;
   */
  codebaseId = 0;

  constructor(data?: PartialMessage<SyncRepositoryRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.SyncRepositoryRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "codebase_id", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SyncRepositoryRequest {
    return new SyncRepositoryRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SyncRepositoryRequest {
    return new SyncRepositoryRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SyncRepositoryRequest {
    return new SyncRepositoryRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SyncRepositoryRequest | PlainMessage<SyncRepositoryRequest> | undefined, b: SyncRepositoryRequest | PlainMessage<SyncRepositoryRequest> | undefined): boolean {
    return proto3.util.equals(SyncRepositoryRequest, a, b);
  }
}

/**
 * @generated from message aiserver.v1.SyncRepositoryResponse
 */
export class SyncRepositoryResponse extends Message<SyncRepositoryResponse> {
  constructor(data?: PartialMessage<SyncRepositoryResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.SyncRepositoryResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SyncRepositoryResponse {
    return new SyncRepositoryResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SyncRepositoryResponse {
    return new SyncRepositoryResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SyncRepositoryResponse {
    return new SyncRepositoryResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SyncRepositoryResponse | PlainMessage<SyncRepositoryResponse> | undefined, b: SyncRepositoryResponse | PlainMessage<SyncRepositoryResponse> | undefined): boolean {
    return proto3.util.equals(SyncRepositoryResponse, a, b);
  }
}

/**
 * @generated from message aiserver.v1.StartUploadRepoRequest
 */
export class StartUploadRepoRequest extends Message<StartUploadRepoRequest> {
  /**
   * @generated from field: aiserver.v1.RepositoryInfo repository = 1;
   */
  repository?: RepositoryInfo;

  constructor(data?: PartialMessage<StartUploadRepoRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.StartUploadRepoRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "repository", kind: "message", T: RepositoryInfo },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StartUploadRepoRequest {
    return new StartUploadRepoRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StartUploadRepoRequest {
    return new StartUploadRepoRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StartUploadRepoRequest {
    return new StartUploadRepoRequest().fromJsonString(jsonString, options);
  }

  static equals(a: StartUploadRepoRequest | PlainMessage<StartUploadRepoRequest> | undefined, b: StartUploadRepoRequest | PlainMessage<StartUploadRepoRequest> | undefined): boolean {
    return proto3.util.equals(StartUploadRepoRequest, a, b);
  }
}

/**
 * @generated from message aiserver.v1.StartUploadRepoResponse
 */
export class StartUploadRepoResponse extends Message<StartUploadRepoResponse> {
  /**
   * @generated from field: aiserver.v1.StartUploadRepoResponse.Status status = 1;
   */
  status = StartUploadRepoResponse_Status.UNSPECIFIED;

  /**
   * @generated from field: repeated string seen_files = 2;
   */
  seenFiles: string[] = [];

  constructor(data?: PartialMessage<StartUploadRepoResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.StartUploadRepoResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "status", kind: "enum", T: proto3.getEnumType(StartUploadRepoResponse_Status) },
    { no: 2, name: "seen_files", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StartUploadRepoResponse {
    return new StartUploadRepoResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StartUploadRepoResponse {
    return new StartUploadRepoResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StartUploadRepoResponse {
    return new StartUploadRepoResponse().fromJsonString(jsonString, options);
  }

  static equals(a: StartUploadRepoResponse | PlainMessage<StartUploadRepoResponse> | undefined, b: StartUploadRepoResponse | PlainMessage<StartUploadRepoResponse> | undefined): boolean {
    return proto3.util.equals(StartUploadRepoResponse, a, b);
  }
}

/**
 * @generated from enum aiserver.v1.StartUploadRepoResponse.Status
 */
export enum StartUploadRepoResponse_Status {
  /**
   * @generated from enum value: STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: STATUS_SUCCESS = 1;
   */
  SUCCESS = 1,

  /**
   * @generated from enum value: STATUS_FAILURE = 2;
   */
  FAILURE = 2,

  /**
   * @generated from enum value: STATUS_ALREADY_EXISTS = 3;
   */
  ALREADY_EXISTS = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(StartUploadRepoResponse_Status)
proto3.util.setEnumType(StartUploadRepoResponse_Status, "aiserver.v1.StartUploadRepoResponse.Status", [
  { no: 0, name: "STATUS_UNSPECIFIED" },
  { no: 1, name: "STATUS_SUCCESS" },
  { no: 2, name: "STATUS_FAILURE" },
  { no: 3, name: "STATUS_ALREADY_EXISTS" },
]);

/**
 * @generated from message aiserver.v1.UploadFileRequest
 */
export class UploadFileRequest extends Message<UploadFileRequest> {
  /**
   * @generated from field: aiserver.v1.RepositoryInfo repository = 1;
   */
  repository?: RepositoryInfo;

  /**
   * @generated from field: aiserver.v1.File file = 2;
   */
  file?: File;

  /**
   * @generated from field: string commit_sha = 3;
   */
  commitSha = "";

  /**
   * @generated from field: string queue_id = 4;
   */
  queueId = "";

  constructor(data?: PartialMessage<UploadFileRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.UploadFileRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "repository", kind: "message", T: RepositoryInfo },
    { no: 2, name: "file", kind: "message", T: File },
    { no: 3, name: "commit_sha", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "queue_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UploadFileRequest {
    return new UploadFileRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UploadFileRequest {
    return new UploadFileRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UploadFileRequest {
    return new UploadFileRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UploadFileRequest | PlainMessage<UploadFileRequest> | undefined, b: UploadFileRequest | PlainMessage<UploadFileRequest> | undefined): boolean {
    return proto3.util.equals(UploadFileRequest, a, b);
  }
}

/**
 * @generated from message aiserver.v1.UploadFileResponse
 */
export class UploadFileResponse extends Message<UploadFileResponse> {
  /**
   * @generated from field: aiserver.v1.UploadFileResponse.Status status = 1;
   */
  status = UploadFileResponse_Status.UNSPECIFIED;

  constructor(data?: PartialMessage<UploadFileResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.UploadFileResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "status", kind: "enum", T: proto3.getEnumType(UploadFileResponse_Status) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UploadFileResponse {
    return new UploadFileResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UploadFileResponse {
    return new UploadFileResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UploadFileResponse {
    return new UploadFileResponse().fromJsonString(jsonString, options);
  }

  static equals(a: UploadFileResponse | PlainMessage<UploadFileResponse> | undefined, b: UploadFileResponse | PlainMessage<UploadFileResponse> | undefined): boolean {
    return proto3.util.equals(UploadFileResponse, a, b);
  }
}

/**
 * @generated from enum aiserver.v1.UploadFileResponse.Status
 */
export enum UploadFileResponse_Status {
  /**
   * @generated from enum value: STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: STATUS_SUCCESS = 1;
   */
  SUCCESS = 1,

  /**
   * @generated from enum value: STATUS_FAILURE = 2;
   */
  FAILURE = 2,

  /**
   * @generated from enum value: STATUS_EXPECTED_FAILURE = 3;
   */
  EXPECTED_FAILURE = 3,

  /**
   * @generated from enum value: STATUS_QUEUE_BACKED_UP = 4;
   */
  QUEUE_BACKED_UP = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(UploadFileResponse_Status)
proto3.util.setEnumType(UploadFileResponse_Status, "aiserver.v1.UploadFileResponse.Status", [
  { no: 0, name: "STATUS_UNSPECIFIED" },
  { no: 1, name: "STATUS_SUCCESS" },
  { no: 2, name: "STATUS_FAILURE" },
  { no: 3, name: "STATUS_EXPECTED_FAILURE" },
  { no: 4, name: "STATUS_QUEUE_BACKED_UP" },
]);

/**
 * @generated from message aiserver.v1.FinishUploadRepoRequest
 */
export class FinishUploadRepoRequest extends Message<FinishUploadRepoRequest> {
  /**
   * @generated from field: aiserver.v1.RepositoryInfo repository = 1;
   */
  repository?: RepositoryInfo;

  constructor(data?: PartialMessage<FinishUploadRepoRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.FinishUploadRepoRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "repository", kind: "message", T: RepositoryInfo },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FinishUploadRepoRequest {
    return new FinishUploadRepoRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FinishUploadRepoRequest {
    return new FinishUploadRepoRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FinishUploadRepoRequest {
    return new FinishUploadRepoRequest().fromJsonString(jsonString, options);
  }

  static equals(a: FinishUploadRepoRequest | PlainMessage<FinishUploadRepoRequest> | undefined, b: FinishUploadRepoRequest | PlainMessage<FinishUploadRepoRequest> | undefined): boolean {
    return proto3.util.equals(FinishUploadRepoRequest, a, b);
  }
}

/**
 * @generated from message aiserver.v1.FinishUploadRepoResponse
 */
export class FinishUploadRepoResponse extends Message<FinishUploadRepoResponse> {
  /**
   * @generated from field: aiserver.v1.FinishUploadRepoResponse.Status status = 1;
   */
  status = FinishUploadRepoResponse_Status.UNSPECIFIED;

  constructor(data?: PartialMessage<FinishUploadRepoResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.FinishUploadRepoResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "status", kind: "enum", T: proto3.getEnumType(FinishUploadRepoResponse_Status) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FinishUploadRepoResponse {
    return new FinishUploadRepoResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FinishUploadRepoResponse {
    return new FinishUploadRepoResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FinishUploadRepoResponse {
    return new FinishUploadRepoResponse().fromJsonString(jsonString, options);
  }

  static equals(a: FinishUploadRepoResponse | PlainMessage<FinishUploadRepoResponse> | undefined, b: FinishUploadRepoResponse | PlainMessage<FinishUploadRepoResponse> | undefined): boolean {
    return proto3.util.equals(FinishUploadRepoResponse, a, b);
  }
}

/**
 * @generated from enum aiserver.v1.FinishUploadRepoResponse.Status
 */
export enum FinishUploadRepoResponse_Status {
  /**
   * @generated from enum value: STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: STATUS_SUCCESS = 1;
   */
  SUCCESS = 1,

  /**
   * @generated from enum value: STATUS_FAILURE = 2;
   */
  FAILURE = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(FinishUploadRepoResponse_Status)
proto3.util.setEnumType(FinishUploadRepoResponse_Status, "aiserver.v1.FinishUploadRepoResponse.Status", [
  { no: 0, name: "STATUS_UNSPECIFIED" },
  { no: 1, name: "STATUS_SUCCESS" },
  { no: 2, name: "STATUS_FAILURE" },
]);

/**
 * @generated from message aiserver.v1.StartUpdateRepoRequest
 */
export class StartUpdateRepoRequest extends Message<StartUpdateRepoRequest> {
  /**
   * @generated from field: aiserver.v1.RepositoryInfo repository = 1;
   */
  repository?: RepositoryInfo;

  constructor(data?: PartialMessage<StartUpdateRepoRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.StartUpdateRepoRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "repository", kind: "message", T: RepositoryInfo },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StartUpdateRepoRequest {
    return new StartUpdateRepoRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StartUpdateRepoRequest {
    return new StartUpdateRepoRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StartUpdateRepoRequest {
    return new StartUpdateRepoRequest().fromJsonString(jsonString, options);
  }

  static equals(a: StartUpdateRepoRequest | PlainMessage<StartUpdateRepoRequest> | undefined, b: StartUpdateRepoRequest | PlainMessage<StartUpdateRepoRequest> | undefined): boolean {
    return proto3.util.equals(StartUpdateRepoRequest, a, b);
  }
}

/**
 * @generated from message aiserver.v1.StartUpdateRepoResponse
 */
export class StartUpdateRepoResponse extends Message<StartUpdateRepoResponse> {
  /**
   * @generated from field: aiserver.v1.StartUpdateRepoResponse.Status status = 1;
   */
  status = StartUpdateRepoResponse_Status.UNSPECIFIED;

  constructor(data?: PartialMessage<StartUpdateRepoResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.StartUpdateRepoResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "status", kind: "enum", T: proto3.getEnumType(StartUpdateRepoResponse_Status) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StartUpdateRepoResponse {
    return new StartUpdateRepoResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StartUpdateRepoResponse {
    return new StartUpdateRepoResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StartUpdateRepoResponse {
    return new StartUpdateRepoResponse().fromJsonString(jsonString, options);
  }

  static equals(a: StartUpdateRepoResponse | PlainMessage<StartUpdateRepoResponse> | undefined, b: StartUpdateRepoResponse | PlainMessage<StartUpdateRepoResponse> | undefined): boolean {
    return proto3.util.equals(StartUpdateRepoResponse, a, b);
  }
}

/**
 * @generated from enum aiserver.v1.StartUpdateRepoResponse.Status
 */
export enum StartUpdateRepoResponse_Status {
  /**
   * @generated from enum value: STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: STATUS_SUCCESS = 1;
   */
  SUCCESS = 1,

  /**
   * @generated from enum value: STATUS_FAILURE = 2;
   */
  FAILURE = 2,

  /**
   * @generated from enum value: STATUS_NOT_FOUND = 3;
   */
  NOT_FOUND = 3,

  /**
   * @generated from enum value: STATUS_ALREADY_SYNCING = 4;
   */
  ALREADY_SYNCING = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(StartUpdateRepoResponse_Status)
proto3.util.setEnumType(StartUpdateRepoResponse_Status, "aiserver.v1.StartUpdateRepoResponse.Status", [
  { no: 0, name: "STATUS_UNSPECIFIED" },
  { no: 1, name: "STATUS_SUCCESS" },
  { no: 2, name: "STATUS_FAILURE" },
  { no: 3, name: "STATUS_NOT_FOUND" },
  { no: 4, name: "STATUS_ALREADY_SYNCING" },
]);

/**
 * @generated from message aiserver.v1.UpdateFileRequest
 */
export class UpdateFileRequest extends Message<UpdateFileRequest> {
  /**
   * @generated from field: aiserver.v1.RepositoryInfo repository = 1;
   */
  repository?: RepositoryInfo;

  /**
   * We either delete, add, or do both
   *
   * @generated from field: aiserver.v1.File added_file = 2;
   */
  addedFile?: File;

  /**
   * @generated from field: optional string deleted_file_path = 3;
   */
  deletedFilePath?: string;

  /**
   * @generated from field: string commit_sha = 4;
   */
  commitSha = "";

  /**
   * @generated from field: string queue_id = 5;
   */
  queueId = "";

  constructor(data?: PartialMessage<UpdateFileRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.UpdateFileRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "repository", kind: "message", T: RepositoryInfo },
    { no: 2, name: "added_file", kind: "message", T: File },
    { no: 3, name: "deleted_file_path", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "commit_sha", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "queue_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateFileRequest {
    return new UpdateFileRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateFileRequest {
    return new UpdateFileRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateFileRequest {
    return new UpdateFileRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateFileRequest | PlainMessage<UpdateFileRequest> | undefined, b: UpdateFileRequest | PlainMessage<UpdateFileRequest> | undefined): boolean {
    return proto3.util.equals(UpdateFileRequest, a, b);
  }
}

/**
 * @generated from message aiserver.v1.UpdateFileResponse
 */
export class UpdateFileResponse extends Message<UpdateFileResponse> {
  /**
   * @generated from field: aiserver.v1.UpdateFileResponse.Status status = 1;
   */
  status = UpdateFileResponse_Status.UNSPECIFIED;

  constructor(data?: PartialMessage<UpdateFileResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.UpdateFileResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "status", kind: "enum", T: proto3.getEnumType(UpdateFileResponse_Status) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateFileResponse {
    return new UpdateFileResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateFileResponse {
    return new UpdateFileResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateFileResponse {
    return new UpdateFileResponse().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateFileResponse | PlainMessage<UpdateFileResponse> | undefined, b: UpdateFileResponse | PlainMessage<UpdateFileResponse> | undefined): boolean {
    return proto3.util.equals(UpdateFileResponse, a, b);
  }
}

/**
 * @generated from enum aiserver.v1.UpdateFileResponse.Status
 */
export enum UpdateFileResponse_Status {
  /**
   * @generated from enum value: STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: STATUS_SUCCESS = 1;
   */
  SUCCESS = 1,

  /**
   * @generated from enum value: STATUS_FAILURE = 2;
   */
  FAILURE = 2,

  /**
   * @generated from enum value: STATUS_EXPECTED_FAILURE = 3;
   */
  EXPECTED_FAILURE = 3,

  /**
   * @generated from enum value: STATUS_QUEUE_BACKED_UP = 4;
   */
  QUEUE_BACKED_UP = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(UpdateFileResponse_Status)
proto3.util.setEnumType(UpdateFileResponse_Status, "aiserver.v1.UpdateFileResponse.Status", [
  { no: 0, name: "STATUS_UNSPECIFIED" },
  { no: 1, name: "STATUS_SUCCESS" },
  { no: 2, name: "STATUS_FAILURE" },
  { no: 3, name: "STATUS_EXPECTED_FAILURE" },
  { no: 4, name: "STATUS_QUEUE_BACKED_UP" },
]);

/**
 * @generated from message aiserver.v1.FinishUpdateRepoRequest
 */
export class FinishUpdateRepoRequest extends Message<FinishUpdateRepoRequest> {
  /**
   * @generated from field: aiserver.v1.RepositoryInfo repository = 1;
   */
  repository?: RepositoryInfo;

  constructor(data?: PartialMessage<FinishUpdateRepoRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.FinishUpdateRepoRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "repository", kind: "message", T: RepositoryInfo },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FinishUpdateRepoRequest {
    return new FinishUpdateRepoRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FinishUpdateRepoRequest {
    return new FinishUpdateRepoRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FinishUpdateRepoRequest {
    return new FinishUpdateRepoRequest().fromJsonString(jsonString, options);
  }

  static equals(a: FinishUpdateRepoRequest | PlainMessage<FinishUpdateRepoRequest> | undefined, b: FinishUpdateRepoRequest | PlainMessage<FinishUpdateRepoRequest> | undefined): boolean {
    return proto3.util.equals(FinishUpdateRepoRequest, a, b);
  }
}

/**
 * @generated from message aiserver.v1.FinishUpdateRepoResponse
 */
export class FinishUpdateRepoResponse extends Message<FinishUpdateRepoResponse> {
  /**
   * @generated from field: aiserver.v1.FinishUpdateRepoResponse.Status status = 1;
   */
  status = FinishUpdateRepoResponse_Status.UNSPECIFIED;

  constructor(data?: PartialMessage<FinishUpdateRepoResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.FinishUpdateRepoResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "status", kind: "enum", T: proto3.getEnumType(FinishUpdateRepoResponse_Status) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FinishUpdateRepoResponse {
    return new FinishUpdateRepoResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FinishUpdateRepoResponse {
    return new FinishUpdateRepoResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FinishUpdateRepoResponse {
    return new FinishUpdateRepoResponse().fromJsonString(jsonString, options);
  }

  static equals(a: FinishUpdateRepoResponse | PlainMessage<FinishUpdateRepoResponse> | undefined, b: FinishUpdateRepoResponse | PlainMessage<FinishUpdateRepoResponse> | undefined): boolean {
    return proto3.util.equals(FinishUpdateRepoResponse, a, b);
  }
}

/**
 * @generated from enum aiserver.v1.FinishUpdateRepoResponse.Status
 */
export enum FinishUpdateRepoResponse_Status {
  /**
   * @generated from enum value: STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: STATUS_SUCCESS = 1;
   */
  SUCCESS = 1,

  /**
   * @generated from enum value: STATUS_FAILURE = 2;
   */
  FAILURE = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(FinishUpdateRepoResponse_Status)
proto3.util.setEnumType(FinishUpdateRepoResponse_Status, "aiserver.v1.FinishUpdateRepoResponse.Status", [
  { no: 0, name: "STATUS_UNSPECIFIED" },
  { no: 1, name: "STATUS_SUCCESS" },
  { no: 2, name: "STATUS_FAILURE" },
]);

/**
 * @generated from message aiserver.v1.BatchRepositoryStatusRequest
 */
export class BatchRepositoryStatusRequest extends Message<BatchRepositoryStatusRequest> {
  /**
   * @generated from field: repeated aiserver.v1.RepositoryStatusRequest requests = 1;
   */
  requests: RepositoryStatusRequest[] = [];

  constructor(data?: PartialMessage<BatchRepositoryStatusRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.BatchRepositoryStatusRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "requests", kind: "message", T: RepositoryStatusRequest, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BatchRepositoryStatusRequest {
    return new BatchRepositoryStatusRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BatchRepositoryStatusRequest {
    return new BatchRepositoryStatusRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BatchRepositoryStatusRequest {
    return new BatchRepositoryStatusRequest().fromJsonString(jsonString, options);
  }

  static equals(a: BatchRepositoryStatusRequest | PlainMessage<BatchRepositoryStatusRequest> | undefined, b: BatchRepositoryStatusRequest | PlainMessage<BatchRepositoryStatusRequest> | undefined): boolean {
    return proto3.util.equals(BatchRepositoryStatusRequest, a, b);
  }
}

/**
 * @generated from message aiserver.v1.BatchRepositoryStatusResponse
 */
export class BatchRepositoryStatusResponse extends Message<BatchRepositoryStatusResponse> {
  /**
   * @generated from field: repeated aiserver.v1.RepositoryStatusResponse responses = 1;
   */
  responses: RepositoryStatusResponse[] = [];

  constructor(data?: PartialMessage<BatchRepositoryStatusResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.BatchRepositoryStatusResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "responses", kind: "message", T: RepositoryStatusResponse, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BatchRepositoryStatusResponse {
    return new BatchRepositoryStatusResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BatchRepositoryStatusResponse {
    return new BatchRepositoryStatusResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BatchRepositoryStatusResponse {
    return new BatchRepositoryStatusResponse().fromJsonString(jsonString, options);
  }

  static equals(a: BatchRepositoryStatusResponse | PlainMessage<BatchRepositoryStatusResponse> | undefined, b: BatchRepositoryStatusResponse | PlainMessage<BatchRepositoryStatusResponse> | undefined): boolean {
    return proto3.util.equals(BatchRepositoryStatusResponse, a, b);
  }
}

/**
 * @generated from message aiserver.v1.UnsubscribeRepositoryRequest
 */
export class UnsubscribeRepositoryRequest extends Message<UnsubscribeRepositoryRequest> {
  /**
   * @generated from field: aiserver.v1.RepositoryInfo repository = 1;
   */
  repository?: RepositoryInfo;

  constructor(data?: PartialMessage<UnsubscribeRepositoryRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.UnsubscribeRepositoryRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "repository", kind: "message", T: RepositoryInfo },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UnsubscribeRepositoryRequest {
    return new UnsubscribeRepositoryRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UnsubscribeRepositoryRequest {
    return new UnsubscribeRepositoryRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UnsubscribeRepositoryRequest {
    return new UnsubscribeRepositoryRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UnsubscribeRepositoryRequest | PlainMessage<UnsubscribeRepositoryRequest> | undefined, b: UnsubscribeRepositoryRequest | PlainMessage<UnsubscribeRepositoryRequest> | undefined): boolean {
    return proto3.util.equals(UnsubscribeRepositoryRequest, a, b);
  }
}

/**
 * @generated from message aiserver.v1.UnsubscribeRepositoryResponse
 */
export class UnsubscribeRepositoryResponse extends Message<UnsubscribeRepositoryResponse> {
  /**
   * @generated from field: aiserver.v1.UnsubscribeRepositoryResponse.Status status = 1;
   */
  status = UnsubscribeRepositoryResponse_Status.UNSPECIFIED;

  constructor(data?: PartialMessage<UnsubscribeRepositoryResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.UnsubscribeRepositoryResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "status", kind: "enum", T: proto3.getEnumType(UnsubscribeRepositoryResponse_Status) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UnsubscribeRepositoryResponse {
    return new UnsubscribeRepositoryResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UnsubscribeRepositoryResponse {
    return new UnsubscribeRepositoryResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UnsubscribeRepositoryResponse {
    return new UnsubscribeRepositoryResponse().fromJsonString(jsonString, options);
  }

  static equals(a: UnsubscribeRepositoryResponse | PlainMessage<UnsubscribeRepositoryResponse> | undefined, b: UnsubscribeRepositoryResponse | PlainMessage<UnsubscribeRepositoryResponse> | undefined): boolean {
    return proto3.util.equals(UnsubscribeRepositoryResponse, a, b);
  }
}

/**
 * @generated from enum aiserver.v1.UnsubscribeRepositoryResponse.Status
 */
export enum UnsubscribeRepositoryResponse_Status {
  /**
   * @generated from enum value: STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: STATUS_NOT_FOUND = 1;
   */
  NOT_FOUND = 1,

  /**
   * @generated from enum value: STATUS_NOT_SUBSCRIBED = 2;
   */
  NOT_SUBSCRIBED = 2,

  /**
   * @generated from enum value: STATUS_SUCCESS = 3;
   */
  SUCCESS = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(UnsubscribeRepositoryResponse_Status)
proto3.util.setEnumType(UnsubscribeRepositoryResponse_Status, "aiserver.v1.UnsubscribeRepositoryResponse.Status", [
  { no: 0, name: "STATUS_UNSPECIFIED" },
  { no: 1, name: "STATUS_NOT_FOUND" },
  { no: 2, name: "STATUS_NOT_SUBSCRIBED" },
  { no: 3, name: "STATUS_SUCCESS" },
]);

/**
 * @generated from message aiserver.v1.LogoutRequest
 */
export class LogoutRequest extends Message<LogoutRequest> {
  constructor(data?: PartialMessage<LogoutRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.LogoutRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LogoutRequest {
    return new LogoutRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LogoutRequest {
    return new LogoutRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LogoutRequest {
    return new LogoutRequest().fromJsonString(jsonString, options);
  }

  static equals(a: LogoutRequest | PlainMessage<LogoutRequest> | undefined, b: LogoutRequest | PlainMessage<LogoutRequest> | undefined): boolean {
    return proto3.util.equals(LogoutRequest, a, b);
  }
}

/**
 * @generated from message aiserver.v1.LogoutResponse
 */
export class LogoutResponse extends Message<LogoutResponse> {
  /**
   * @generated from field: aiserver.v1.LogoutResponse.Status status = 1;
   */
  status = LogoutResponse_Status.UNSPECIFIED;

  constructor(data?: PartialMessage<LogoutResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.LogoutResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "status", kind: "enum", T: proto3.getEnumType(LogoutResponse_Status) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LogoutResponse {
    return new LogoutResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LogoutResponse {
    return new LogoutResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LogoutResponse {
    return new LogoutResponse().fromJsonString(jsonString, options);
  }

  static equals(a: LogoutResponse | PlainMessage<LogoutResponse> | undefined, b: LogoutResponse | PlainMessage<LogoutResponse> | undefined): boolean {
    return proto3.util.equals(LogoutResponse, a, b);
  }
}

/**
 * @generated from enum aiserver.v1.LogoutResponse.Status
 */
export enum LogoutResponse_Status {
  /**
   * @generated from enum value: STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: STATUS_SUCCESS = 1;
   */
  SUCCESS = 1,

  /**
   * @generated from enum value: STATUS_FAILURE = 2;
   */
  FAILURE = 2,

  /**
   * @generated from enum value: STATUS_NOT_LOGGED_IN = 3;
   */
  NOT_LOGGED_IN = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(LogoutResponse_Status)
proto3.util.setEnumType(LogoutResponse_Status, "aiserver.v1.LogoutResponse.Status", [
  { no: 0, name: "STATUS_UNSPECIFIED" },
  { no: 1, name: "STATUS_SUCCESS" },
  { no: 2, name: "STATUS_FAILURE" },
  { no: 3, name: "STATUS_NOT_LOGGED_IN" },
]);

/**
 * @generated from message aiserver.v1.RemoveRepositoryRequest
 */
export class RemoveRepositoryRequest extends Message<RemoveRepositoryRequest> {
  /**
   * @generated from field: aiserver.v1.RepositoryInfo repository = 1;
   */
  repository?: RepositoryInfo;

  constructor(data?: PartialMessage<RemoveRepositoryRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.RemoveRepositoryRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "repository", kind: "message", T: RepositoryInfo },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RemoveRepositoryRequest {
    return new RemoveRepositoryRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RemoveRepositoryRequest {
    return new RemoveRepositoryRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RemoveRepositoryRequest {
    return new RemoveRepositoryRequest().fromJsonString(jsonString, options);
  }

  static equals(a: RemoveRepositoryRequest | PlainMessage<RemoveRepositoryRequest> | undefined, b: RemoveRepositoryRequest | PlainMessage<RemoveRepositoryRequest> | undefined): boolean {
    return proto3.util.equals(RemoveRepositoryRequest, a, b);
  }
}

/**
 * @generated from message aiserver.v1.RemoveRepositoryResponse
 */
export class RemoveRepositoryResponse extends Message<RemoveRepositoryResponse> {
  /**
   * @generated from field: aiserver.v1.RemoveRepositoryResponse.Status status = 1;
   */
  status = RemoveRepositoryResponse_Status.UNSPECIFIED;

  constructor(data?: PartialMessage<RemoveRepositoryResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.RemoveRepositoryResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "status", kind: "enum", T: proto3.getEnumType(RemoveRepositoryResponse_Status) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RemoveRepositoryResponse {
    return new RemoveRepositoryResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RemoveRepositoryResponse {
    return new RemoveRepositoryResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RemoveRepositoryResponse {
    return new RemoveRepositoryResponse().fromJsonString(jsonString, options);
  }

  static equals(a: RemoveRepositoryResponse | PlainMessage<RemoveRepositoryResponse> | undefined, b: RemoveRepositoryResponse | PlainMessage<RemoveRepositoryResponse> | undefined): boolean {
    return proto3.util.equals(RemoveRepositoryResponse, a, b);
  }
}

/**
 * @generated from enum aiserver.v1.RemoveRepositoryResponse.Status
 */
export enum RemoveRepositoryResponse_Status {
  /**
   * @generated from enum value: STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: STATUS_NOT_FOUND = 1;
   */
  NOT_FOUND = 1,

  /**
   * @generated from enum value: STATUS_NOT_AUTHORIZED = 2;
   */
  NOT_AUTHORIZED = 2,

  /**
   * @generated from enum value: STATUS_STARTED = 3;
   */
  STARTED = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(RemoveRepositoryResponse_Status)
proto3.util.setEnumType(RemoveRepositoryResponse_Status, "aiserver.v1.RemoveRepositoryResponse.Status", [
  { no: 0, name: "STATUS_UNSPECIFIED" },
  { no: 1, name: "STATUS_NOT_FOUND" },
  { no: 2, name: "STATUS_NOT_AUTHORIZED" },
  { no: 3, name: "STATUS_STARTED" },
]);

/**
 * @generated from message aiserver.v1.SubscribeRepositoryRequest
 */
export class SubscribeRepositoryRequest extends Message<SubscribeRepositoryRequest> {
  /**
   * @generated from field: aiserver.v1.RepositoryInfo repository = 1;
   */
  repository?: RepositoryInfo;

  constructor(data?: PartialMessage<SubscribeRepositoryRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.SubscribeRepositoryRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "repository", kind: "message", T: RepositoryInfo },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubscribeRepositoryRequest {
    return new SubscribeRepositoryRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubscribeRepositoryRequest {
    return new SubscribeRepositoryRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubscribeRepositoryRequest {
    return new SubscribeRepositoryRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SubscribeRepositoryRequest | PlainMessage<SubscribeRepositoryRequest> | undefined, b: SubscribeRepositoryRequest | PlainMessage<SubscribeRepositoryRequest> | undefined): boolean {
    return proto3.util.equals(SubscribeRepositoryRequest, a, b);
  }
}

/**
 * @generated from message aiserver.v1.SubscribeRepositoryResponse
 */
export class SubscribeRepositoryResponse extends Message<SubscribeRepositoryResponse> {
  /**
   * @generated from field: aiserver.v1.SubscribeRepositoryResponse.Status status = 1;
   */
  status = SubscribeRepositoryResponse_Status.UNSPECIFIED;

  constructor(data?: PartialMessage<SubscribeRepositoryResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.SubscribeRepositoryResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "status", kind: "enum", T: proto3.getEnumType(SubscribeRepositoryResponse_Status) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubscribeRepositoryResponse {
    return new SubscribeRepositoryResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubscribeRepositoryResponse {
    return new SubscribeRepositoryResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubscribeRepositoryResponse {
    return new SubscribeRepositoryResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SubscribeRepositoryResponse | PlainMessage<SubscribeRepositoryResponse> | undefined, b: SubscribeRepositoryResponse | PlainMessage<SubscribeRepositoryResponse> | undefined): boolean {
    return proto3.util.equals(SubscribeRepositoryResponse, a, b);
  }
}

/**
 * @generated from enum aiserver.v1.SubscribeRepositoryResponse.Status
 */
export enum SubscribeRepositoryResponse_Status {
  /**
   * @generated from enum value: STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: STATUS_NOT_FOUND = 1;
   */
  NOT_FOUND = 1,

  /**
   * @generated from enum value: STATUS_NOT_AUTHORIZED = 2;
   */
  NOT_AUTHORIZED = 2,

  /**
   * @generated from enum value: STATUS_ALREADY_SUBSCRIBED = 3;
   */
  ALREADY_SUBSCRIBED = 3,

  /**
   * @generated from enum value: STATUS_SUCCESS = 4;
   */
  SUCCESS = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(SubscribeRepositoryResponse_Status)
proto3.util.setEnumType(SubscribeRepositoryResponse_Status, "aiserver.v1.SubscribeRepositoryResponse.Status", [
  { no: 0, name: "STATUS_UNSPECIFIED" },
  { no: 1, name: "STATUS_NOT_FOUND" },
  { no: 2, name: "STATUS_NOT_AUTHORIZED" },
  { no: 3, name: "STATUS_ALREADY_SUBSCRIBED" },
  { no: 4, name: "STATUS_SUCCESS" },
]);

/**
 * @generated from message aiserver.v1.SearchRepositoryRequest
 */
export class SearchRepositoryRequest extends Message<SearchRepositoryRequest> {
  /**
   * @generated from field: string query = 1;
   */
  query = "";

  /**
   * @generated from field: aiserver.v1.RepositoryInfo repository = 2;
   */
  repository?: RepositoryInfo;

  /**
   * @generated from field: int32 top_k = 3;
   */
  topK = 0;

  /**
   * @generated from field: aiserver.v1.ModelDetails model_details = 4;
   */
  modelDetails?: ModelDetails;

  /**
   * @generated from field: bool rerank = 5;
   */
  rerank = false;

  /**
   * @generated from field: optional bool context_cache_request = 6;
   */
  contextCacheRequest?: boolean;

  constructor(data?: PartialMessage<SearchRepositoryRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.SearchRepositoryRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "query", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "repository", kind: "message", T: RepositoryInfo },
    { no: 3, name: "top_k", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "model_details", kind: "message", T: ModelDetails },
    { no: 5, name: "rerank", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "context_cache_request", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchRepositoryRequest {
    return new SearchRepositoryRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchRepositoryRequest {
    return new SearchRepositoryRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchRepositoryRequest {
    return new SearchRepositoryRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SearchRepositoryRequest | PlainMessage<SearchRepositoryRequest> | undefined, b: SearchRepositoryRequest | PlainMessage<SearchRepositoryRequest> | undefined): boolean {
    return proto3.util.equals(SearchRepositoryRequest, a, b);
  }
}

/**
 * @generated from message aiserver.v1.CodeResult
 */
export class CodeResult extends Message<CodeResult> {
  /**
   * @generated from field: aiserver.v1.CodeBlock code_block = 1;
   */
  codeBlock?: CodeBlock;

  /**
   * @generated from field: float score = 2;
   */
  score = 0;

  constructor(data?: PartialMessage<CodeResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.CodeResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "code_block", kind: "message", T: CodeBlock },
    { no: 2, name: "score", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CodeResult {
    return new CodeResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CodeResult {
    return new CodeResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CodeResult {
    return new CodeResult().fromJsonString(jsonString, options);
  }

  static equals(a: CodeResult | PlainMessage<CodeResult> | undefined, b: CodeResult | PlainMessage<CodeResult> | undefined): boolean {
    return proto3.util.equals(CodeResult, a, b);
  }
}

/**
 * @generated from message aiserver.v1.FileResult
 */
export class FileResult extends Message<FileResult> {
  /**
   * @generated from field: aiserver.v1.File file = 1;
   */
  file?: File;

  /**
   * @generated from field: float score = 2;
   */
  score = 0;

  constructor(data?: PartialMessage<FileResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.FileResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "file", kind: "message", T: File },
    { no: 2, name: "score", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FileResult {
    return new FileResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FileResult {
    return new FileResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FileResult {
    return new FileResult().fromJsonString(jsonString, options);
  }

  static equals(a: FileResult | PlainMessage<FileResult> | undefined, b: FileResult | PlainMessage<FileResult> | undefined): boolean {
    return proto3.util.equals(FileResult, a, b);
  }
}

/**
 * @generated from message aiserver.v1.SearchRepositoryResponse
 */
export class SearchRepositoryResponse extends Message<SearchRepositoryResponse> {
  /**
   * @generated from field: repeated aiserver.v1.CodeResult code_results = 1;
   */
  codeResults: CodeResult[] = [];

  constructor(data?: PartialMessage<SearchRepositoryResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.SearchRepositoryResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "code_results", kind: "message", T: CodeResult, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchRepositoryResponse {
    return new SearchRepositoryResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchRepositoryResponse {
    return new SearchRepositoryResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchRepositoryResponse {
    return new SearchRepositoryResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SearchRepositoryResponse | PlainMessage<SearchRepositoryResponse> | undefined, b: SearchRepositoryResponse | PlainMessage<SearchRepositoryResponse> | undefined): boolean {
    return proto3.util.equals(SearchRepositoryResponse, a, b);
  }
}

/**
 * By default they already provide their auth0 id, so this contains
 * no information for now
 *
 * @generated from message aiserver.v1.LoginRequest
 */
export class LoginRequest extends Message<LoginRequest> {
  constructor(data?: PartialMessage<LoginRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.LoginRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LoginRequest {
    return new LoginRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LoginRequest {
    return new LoginRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LoginRequest {
    return new LoginRequest().fromJsonString(jsonString, options);
  }

  static equals(a: LoginRequest | PlainMessage<LoginRequest> | undefined, b: LoginRequest | PlainMessage<LoginRequest> | undefined): boolean {
    return proto3.util.equals(LoginRequest, a, b);
  }
}

/**
 * @generated from message aiserver.v1.LoginResponse
 */
export class LoginResponse extends Message<LoginResponse> {
  /**
   * This is the URL that the user should be redirected to
   * in order to login
   *
   * @generated from field: string login_url = 1;
   */
  loginUrl = "";

  constructor(data?: PartialMessage<LoginResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.LoginResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "login_url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LoginResponse {
    return new LoginResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LoginResponse {
    return new LoginResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LoginResponse {
    return new LoginResponse().fromJsonString(jsonString, options);
  }

  static equals(a: LoginResponse | PlainMessage<LoginResponse> | undefined, b: LoginResponse | PlainMessage<LoginResponse> | undefined): boolean {
    return proto3.util.equals(LoginResponse, a, b);
  }
}

/**
 * @generated from message aiserver.v1.IsLoggedInRequest
 */
export class IsLoggedInRequest extends Message<IsLoggedInRequest> {
  constructor(data?: PartialMessage<IsLoggedInRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.IsLoggedInRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IsLoggedInRequest {
    return new IsLoggedInRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IsLoggedInRequest {
    return new IsLoggedInRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IsLoggedInRequest {
    return new IsLoggedInRequest().fromJsonString(jsonString, options);
  }

  static equals(a: IsLoggedInRequest | PlainMessage<IsLoggedInRequest> | undefined, b: IsLoggedInRequest | PlainMessage<IsLoggedInRequest> | undefined): boolean {
    return proto3.util.equals(IsLoggedInRequest, a, b);
  }
}

/**
 * @generated from message aiserver.v1.IsLoggedInResponse
 */
export class IsLoggedInResponse extends Message<IsLoggedInResponse> {
  /**
   * @generated from field: bool logged_in = 1;
   */
  loggedIn = false;

  constructor(data?: PartialMessage<IsLoggedInResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.IsLoggedInResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "logged_in", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IsLoggedInResponse {
    return new IsLoggedInResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IsLoggedInResponse {
    return new IsLoggedInResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IsLoggedInResponse {
    return new IsLoggedInResponse().fromJsonString(jsonString, options);
  }

  static equals(a: IsLoggedInResponse | PlainMessage<IsLoggedInResponse> | undefined, b: IsLoggedInResponse | PlainMessage<IsLoggedInResponse> | undefined): boolean {
    return proto3.util.equals(IsLoggedInResponse, a, b);
  }
}

/**
 * @generated from message aiserver.v1.PollLoginRequest
 */
export class PollLoginRequest extends Message<PollLoginRequest> {
  constructor(data?: PartialMessage<PollLoginRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.PollLoginRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PollLoginRequest {
    return new PollLoginRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PollLoginRequest {
    return new PollLoginRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PollLoginRequest {
    return new PollLoginRequest().fromJsonString(jsonString, options);
  }

  static equals(a: PollLoginRequest | PlainMessage<PollLoginRequest> | undefined, b: PollLoginRequest | PlainMessage<PollLoginRequest> | undefined): boolean {
    return proto3.util.equals(PollLoginRequest, a, b);
  }
}

/**
 * @generated from message aiserver.v1.PollLoginResponse
 */
export class PollLoginResponse extends Message<PollLoginResponse> {
  /**
   * @generated from field: aiserver.v1.PollLoginResponse.Status status = 1;
   */
  status = PollLoginResponse_Status.UNSPECIFIED;

  constructor(data?: PartialMessage<PollLoginResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.PollLoginResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "status", kind: "enum", T: proto3.getEnumType(PollLoginResponse_Status) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PollLoginResponse {
    return new PollLoginResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PollLoginResponse {
    return new PollLoginResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PollLoginResponse {
    return new PollLoginResponse().fromJsonString(jsonString, options);
  }

  static equals(a: PollLoginResponse | PlainMessage<PollLoginResponse> | undefined, b: PollLoginResponse | PlainMessage<PollLoginResponse> | undefined): boolean {
    return proto3.util.equals(PollLoginResponse, a, b);
  }
}

/**
 * @generated from enum aiserver.v1.PollLoginResponse.Status
 */
export enum PollLoginResponse_Status {
  /**
   * @generated from enum value: STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: STATUS_LOGGED_IN = 1;
   */
  LOGGED_IN = 1,

  /**
   * @generated from enum value: STATUS_FAILURE = 2;
   */
  FAILURE = 2,

  /**
   * @generated from enum value: STATUS_CHECKING = 3;
   */
  CHECKING = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(PollLoginResponse_Status)
proto3.util.setEnumType(PollLoginResponse_Status, "aiserver.v1.PollLoginResponse.Status", [
  { no: 0, name: "STATUS_UNSPECIFIED" },
  { no: 1, name: "STATUS_LOGGED_IN" },
  { no: 2, name: "STATUS_FAILURE" },
  { no: 3, name: "STATUS_CHECKING" },
]);

/**
 * @generated from message aiserver.v1.UpgradeScopeRequest
 */
export class UpgradeScopeRequest extends Message<UpgradeScopeRequest> {
  /**
   * We ask for the new scopes requested
   *
   * @generated from field: repeated string scopes = 2;
   */
  scopes: string[] = [];

  constructor(data?: PartialMessage<UpgradeScopeRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.UpgradeScopeRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "scopes", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpgradeScopeRequest {
    return new UpgradeScopeRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpgradeScopeRequest {
    return new UpgradeScopeRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpgradeScopeRequest {
    return new UpgradeScopeRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpgradeScopeRequest | PlainMessage<UpgradeScopeRequest> | undefined, b: UpgradeScopeRequest | PlainMessage<UpgradeScopeRequest> | undefined): boolean {
    return proto3.util.equals(UpgradeScopeRequest, a, b);
  }
}

/**
 * @generated from message aiserver.v1.UpgradeScopeResponse
 */
export class UpgradeScopeResponse extends Message<UpgradeScopeResponse> {
  /**
   * @generated from field: aiserver.v1.UpgradeScopeResponse.Status status = 1;
   */
  status = UpgradeScopeResponse_Status.UNSPECIFIED;

  constructor(data?: PartialMessage<UpgradeScopeResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.UpgradeScopeResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "status", kind: "enum", T: proto3.getEnumType(UpgradeScopeResponse_Status) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpgradeScopeResponse {
    return new UpgradeScopeResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpgradeScopeResponse {
    return new UpgradeScopeResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpgradeScopeResponse {
    return new UpgradeScopeResponse().fromJsonString(jsonString, options);
  }

  static equals(a: UpgradeScopeResponse | PlainMessage<UpgradeScopeResponse> | undefined, b: UpgradeScopeResponse | PlainMessage<UpgradeScopeResponse> | undefined): boolean {
    return proto3.util.equals(UpgradeScopeResponse, a, b);
  }
}

/**
 * @generated from enum aiserver.v1.UpgradeScopeResponse.Status
 */
export enum UpgradeScopeResponse_Status {
  /**
   * @generated from enum value: STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: STATUS_SUCCESS = 1;
   */
  SUCCESS = 1,

  /**
   * @generated from enum value: STATUS_FAILURE = 2;
   */
  FAILURE = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(UpgradeScopeResponse_Status)
proto3.util.setEnumType(UpgradeScopeResponse_Status, "aiserver.v1.UpgradeScopeResponse.Status", [
  { no: 0, name: "STATUS_UNSPECIFIED" },
  { no: 1, name: "STATUS_SUCCESS" },
  { no: 2, name: "STATUS_FAILURE" },
]);

/**
 * Provides a list of available repositories
 *
 * @generated from message aiserver.v1.RepositoriesRequest
 */
export class RepositoriesRequest extends Message<RepositoriesRequest> {
  constructor(data?: PartialMessage<RepositoriesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.RepositoriesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RepositoriesRequest {
    return new RepositoriesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RepositoriesRequest {
    return new RepositoriesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RepositoriesRequest {
    return new RepositoriesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: RepositoriesRequest | PlainMessage<RepositoriesRequest> | undefined, b: RepositoriesRequest | PlainMessage<RepositoriesRequest> | undefined): boolean {
    return proto3.util.equals(RepositoriesRequest, a, b);
  }
}

/**
 * @generated from message aiserver.v1.RepositoriesResponse
 */
export class RepositoriesResponse extends Message<RepositoriesResponse> {
  /**
   * The list of repositories found
   *
   * @generated from field: repeated aiserver.v1.RepositoryInfo repositories = 1;
   */
  repositories: RepositoryInfo[] = [];

  constructor(data?: PartialMessage<RepositoriesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.RepositoriesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "repositories", kind: "message", T: RepositoryInfo, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RepositoriesResponse {
    return new RepositoriesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RepositoriesResponse {
    return new RepositoriesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RepositoriesResponse {
    return new RepositoriesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: RepositoriesResponse | PlainMessage<RepositoriesResponse> | undefined, b: RepositoriesResponse | PlainMessage<RepositoriesResponse> | undefined): boolean {
    return proto3.util.equals(RepositoriesResponse, a, b);
  }
}

/**
 * @generated from message aiserver.v1.UploadRepositoryRequest
 */
export class UploadRepositoryRequest extends Message<UploadRepositoryRequest> {
  /**
   * The repository to upload
   *
   * @generated from field: aiserver.v1.RepositoryInfo repository = 1;
   */
  repository?: RepositoryInfo;

  constructor(data?: PartialMessage<UploadRepositoryRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.UploadRepositoryRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "repository", kind: "message", T: RepositoryInfo },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UploadRepositoryRequest {
    return new UploadRepositoryRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UploadRepositoryRequest {
    return new UploadRepositoryRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UploadRepositoryRequest {
    return new UploadRepositoryRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UploadRepositoryRequest | PlainMessage<UploadRepositoryRequest> | undefined, b: UploadRepositoryRequest | PlainMessage<UploadRepositoryRequest> | undefined): boolean {
    return proto3.util.equals(UploadRepositoryRequest, a, b);
  }
}

/**
 * @generated from message aiserver.v1.UploadRepositoryResponse
 */
export class UploadRepositoryResponse extends Message<UploadRepositoryResponse> {
  /**
   * @generated from field: aiserver.v1.UploadRepositoryResponse.Status status = 1;
   */
  status = UploadRepositoryResponse_Status.UNSPECIFIED;

  constructor(data?: PartialMessage<UploadRepositoryResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.UploadRepositoryResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "status", kind: "enum", T: proto3.getEnumType(UploadRepositoryResponse_Status) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UploadRepositoryResponse {
    return new UploadRepositoryResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UploadRepositoryResponse {
    return new UploadRepositoryResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UploadRepositoryResponse {
    return new UploadRepositoryResponse().fromJsonString(jsonString, options);
  }

  static equals(a: UploadRepositoryResponse | PlainMessage<UploadRepositoryResponse> | undefined, b: UploadRepositoryResponse | PlainMessage<UploadRepositoryResponse> | undefined): boolean {
    return proto3.util.equals(UploadRepositoryResponse, a, b);
  }
}

/**
 * The status of the upload
 *
 * @generated from enum aiserver.v1.UploadRepositoryResponse.Status
 */
export enum UploadRepositoryResponse_Status {
  /**
   * @generated from enum value: STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: STATUS_SUCCESS = 1;
   */
  SUCCESS = 1,

  /**
   * @generated from enum value: STATUS_FAILURE = 2;
   */
  FAILURE = 2,

  /**
   * @generated from enum value: STATUS_AUTH_TOKEN_BAD_PERMISSIONS = 3;
   */
  AUTH_TOKEN_BAD_PERMISSIONS = 3,

  /**
   * @generated from enum value: STATUS_ALREADY_EXISTS = 4;
   */
  ALREADY_EXISTS = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(UploadRepositoryResponse_Status)
proto3.util.setEnumType(UploadRepositoryResponse_Status, "aiserver.v1.UploadRepositoryResponse.Status", [
  { no: 0, name: "STATUS_UNSPECIFIED" },
  { no: 1, name: "STATUS_SUCCESS" },
  { no: 2, name: "STATUS_FAILURE" },
  { no: 3, name: "STATUS_AUTH_TOKEN_BAD_PERMISSIONS" },
  { no: 4, name: "STATUS_ALREADY_EXISTS" },
]);

/**
 * @generated from message aiserver.v1.RepositoryStatusRequest
 */
export class RepositoryStatusRequest extends Message<RepositoryStatusRequest> {
  /**
   * @generated from field: aiserver.v1.RepositoryInfo repository = 1;
   */
  repository?: RepositoryInfo;

  constructor(data?: PartialMessage<RepositoryStatusRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.RepositoryStatusRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "repository", kind: "message", T: RepositoryInfo },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RepositoryStatusRequest {
    return new RepositoryStatusRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RepositoryStatusRequest {
    return new RepositoryStatusRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RepositoryStatusRequest {
    return new RepositoryStatusRequest().fromJsonString(jsonString, options);
  }

  static equals(a: RepositoryStatusRequest | PlainMessage<RepositoryStatusRequest> | undefined, b: RepositoryStatusRequest | PlainMessage<RepositoryStatusRequest> | undefined): boolean {
    return proto3.util.equals(RepositoryStatusRequest, a, b);
  }
}

/**
 * @generated from message aiserver.v1.RepositoryStatusResponse
 */
export class RepositoryStatusResponse extends Message<RepositoryStatusResponse> {
  /**
   * @generated from oneof aiserver.v1.RepositoryStatusResponse.status
   */
  status: {
    /**
     * @generated from field: aiserver.v1.RepositoryStatusResponse.NotFound not_found = 1;
     */
    value: RepositoryStatusResponse_NotFound;
    case: "notFound";
  } | {
    /**
     * @generated from field: aiserver.v1.RepositoryStatusResponse.Uploading uploading = 2;
     */
    value: RepositoryStatusResponse_Uploading;
    case: "uploading";
  } | {
    /**
     * @generated from field: aiserver.v1.RepositoryStatusResponse.Syncing syncing = 3;
     */
    value: RepositoryStatusResponse_Syncing;
    case: "syncing";
  } | {
    /**
     * @generated from field: aiserver.v1.RepositoryStatusResponse.Synced synced = 4;
     */
    value: RepositoryStatusResponse_Synced;
    case: "synced";
  } | {
    /**
     * @generated from field: aiserver.v1.RepositoryStatusResponse.NotSubscribed not_subscribed = 5;
     */
    value: RepositoryStatusResponse_NotSubscribed;
    case: "notSubscribed";
  } | {
    /**
     * @generated from field: aiserver.v1.RepositoryStatusResponse.TooBig too_big = 6;
     */
    value: RepositoryStatusResponse_TooBig;
    case: "tooBig";
  } | {
    /**
     * @generated from field: aiserver.v1.RepositoryStatusResponse.AuthTokenNotFound auth_token_not_found = 7;
     */
    value: RepositoryStatusResponse_AuthTokenNotFound;
    case: "authTokenNotFound";
  } | {
    /**
     * @generated from field: aiserver.v1.RepositoryStatusResponse.AuthTokenNotAuthorized auth_token_not_authorized = 8;
     */
    value: RepositoryStatusResponse_AuthTokenNotAuthorized;
    case: "authTokenNotAuthorized";
  } | {
    /**
     * @generated from field: aiserver.v1.RepositoryStatusResponse.EmptyMessage error_uploading = 10;
     */
    value: RepositoryStatusResponse_EmptyMessage;
    case: "errorUploading";
  } | {
    /**
     * @generated from field: aiserver.v1.RepositoryStatusResponse.EmptyMessage error_syncing = 11;
     */
    value: RepositoryStatusResponse_EmptyMessage;
    case: "errorSyncing";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * @generated from field: optional bool is_owner = 9;
   */
  isOwner?: boolean;

  constructor(data?: PartialMessage<RepositoryStatusResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.RepositoryStatusResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "not_found", kind: "message", T: RepositoryStatusResponse_NotFound, oneof: "status" },
    { no: 2, name: "uploading", kind: "message", T: RepositoryStatusResponse_Uploading, oneof: "status" },
    { no: 3, name: "syncing", kind: "message", T: RepositoryStatusResponse_Syncing, oneof: "status" },
    { no: 4, name: "synced", kind: "message", T: RepositoryStatusResponse_Synced, oneof: "status" },
    { no: 5, name: "not_subscribed", kind: "message", T: RepositoryStatusResponse_NotSubscribed, oneof: "status" },
    { no: 6, name: "too_big", kind: "message", T: RepositoryStatusResponse_TooBig, oneof: "status" },
    { no: 7, name: "auth_token_not_found", kind: "message", T: RepositoryStatusResponse_AuthTokenNotFound, oneof: "status" },
    { no: 8, name: "auth_token_not_authorized", kind: "message", T: RepositoryStatusResponse_AuthTokenNotAuthorized, oneof: "status" },
    { no: 10, name: "error_uploading", kind: "message", T: RepositoryStatusResponse_EmptyMessage, oneof: "status" },
    { no: 11, name: "error_syncing", kind: "message", T: RepositoryStatusResponse_EmptyMessage, oneof: "status" },
    { no: 9, name: "is_owner", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RepositoryStatusResponse {
    return new RepositoryStatusResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RepositoryStatusResponse {
    return new RepositoryStatusResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RepositoryStatusResponse {
    return new RepositoryStatusResponse().fromJsonString(jsonString, options);
  }

  static equals(a: RepositoryStatusResponse | PlainMessage<RepositoryStatusResponse> | undefined, b: RepositoryStatusResponse | PlainMessage<RepositoryStatusResponse> | undefined): boolean {
    return proto3.util.equals(RepositoryStatusResponse, a, b);
  }
}

/**
 * @generated from message aiserver.v1.RepositoryStatusResponse.NotFound
 */
export class RepositoryStatusResponse_NotFound extends Message<RepositoryStatusResponse_NotFound> {
  constructor(data?: PartialMessage<RepositoryStatusResponse_NotFound>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.RepositoryStatusResponse.NotFound";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RepositoryStatusResponse_NotFound {
    return new RepositoryStatusResponse_NotFound().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RepositoryStatusResponse_NotFound {
    return new RepositoryStatusResponse_NotFound().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RepositoryStatusResponse_NotFound {
    return new RepositoryStatusResponse_NotFound().fromJsonString(jsonString, options);
  }

  static equals(a: RepositoryStatusResponse_NotFound | PlainMessage<RepositoryStatusResponse_NotFound> | undefined, b: RepositoryStatusResponse_NotFound | PlainMessage<RepositoryStatusResponse_NotFound> | undefined): boolean {
    return proto3.util.equals(RepositoryStatusResponse_NotFound, a, b);
  }
}

/**
 * @generated from message aiserver.v1.RepositoryStatusResponse.NotSubscribed
 */
export class RepositoryStatusResponse_NotSubscribed extends Message<RepositoryStatusResponse_NotSubscribed> {
  constructor(data?: PartialMessage<RepositoryStatusResponse_NotSubscribed>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.RepositoryStatusResponse.NotSubscribed";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RepositoryStatusResponse_NotSubscribed {
    return new RepositoryStatusResponse_NotSubscribed().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RepositoryStatusResponse_NotSubscribed {
    return new RepositoryStatusResponse_NotSubscribed().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RepositoryStatusResponse_NotSubscribed {
    return new RepositoryStatusResponse_NotSubscribed().fromJsonString(jsonString, options);
  }

  static equals(a: RepositoryStatusResponse_NotSubscribed | PlainMessage<RepositoryStatusResponse_NotSubscribed> | undefined, b: RepositoryStatusResponse_NotSubscribed | PlainMessage<RepositoryStatusResponse_NotSubscribed> | undefined): boolean {
    return proto3.util.equals(RepositoryStatusResponse_NotSubscribed, a, b);
  }
}

/**
 * @generated from message aiserver.v1.RepositoryStatusResponse.Uploading
 */
export class RepositoryStatusResponse_Uploading extends Message<RepositoryStatusResponse_Uploading> {
  /**
   * @generated from field: float progress = 1;
   */
  progress = 0;

  constructor(data?: PartialMessage<RepositoryStatusResponse_Uploading>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.RepositoryStatusResponse.Uploading";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "progress", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RepositoryStatusResponse_Uploading {
    return new RepositoryStatusResponse_Uploading().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RepositoryStatusResponse_Uploading {
    return new RepositoryStatusResponse_Uploading().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RepositoryStatusResponse_Uploading {
    return new RepositoryStatusResponse_Uploading().fromJsonString(jsonString, options);
  }

  static equals(a: RepositoryStatusResponse_Uploading | PlainMessage<RepositoryStatusResponse_Uploading> | undefined, b: RepositoryStatusResponse_Uploading | PlainMessage<RepositoryStatusResponse_Uploading> | undefined): boolean {
    return proto3.util.equals(RepositoryStatusResponse_Uploading, a, b);
  }
}

/**
 * @generated from message aiserver.v1.RepositoryStatusResponse.Syncing
 */
export class RepositoryStatusResponse_Syncing extends Message<RepositoryStatusResponse_Syncing> {
  /**
   * @generated from field: string branch = 1;
   */
  branch = "";

  /**
   * @generated from field: string old_commit = 2;
   */
  oldCommit = "";

  /**
   * @generated from field: string new_commit = 3;
   */
  newCommit = "";

  /**
   * @generated from field: float progress = 4;
   */
  progress = 0;

  constructor(data?: PartialMessage<RepositoryStatusResponse_Syncing>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.RepositoryStatusResponse.Syncing";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "branch", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "old_commit", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "new_commit", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "progress", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RepositoryStatusResponse_Syncing {
    return new RepositoryStatusResponse_Syncing().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RepositoryStatusResponse_Syncing {
    return new RepositoryStatusResponse_Syncing().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RepositoryStatusResponse_Syncing {
    return new RepositoryStatusResponse_Syncing().fromJsonString(jsonString, options);
  }

  static equals(a: RepositoryStatusResponse_Syncing | PlainMessage<RepositoryStatusResponse_Syncing> | undefined, b: RepositoryStatusResponse_Syncing | PlainMessage<RepositoryStatusResponse_Syncing> | undefined): boolean {
    return proto3.util.equals(RepositoryStatusResponse_Syncing, a, b);
  }
}

/**
 * @generated from message aiserver.v1.RepositoryStatusResponse.Synced
 */
export class RepositoryStatusResponse_Synced extends Message<RepositoryStatusResponse_Synced> {
  /**
   * @generated from field: string branch = 1;
   */
  branch = "";

  /**
   * @generated from field: string commit = 2;
   */
  commit = "";

  constructor(data?: PartialMessage<RepositoryStatusResponse_Synced>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.RepositoryStatusResponse.Synced";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "branch", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "commit", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RepositoryStatusResponse_Synced {
    return new RepositoryStatusResponse_Synced().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RepositoryStatusResponse_Synced {
    return new RepositoryStatusResponse_Synced().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RepositoryStatusResponse_Synced {
    return new RepositoryStatusResponse_Synced().fromJsonString(jsonString, options);
  }

  static equals(a: RepositoryStatusResponse_Synced | PlainMessage<RepositoryStatusResponse_Synced> | undefined, b: RepositoryStatusResponse_Synced | PlainMessage<RepositoryStatusResponse_Synced> | undefined): boolean {
    return proto3.util.equals(RepositoryStatusResponse_Synced, a, b);
  }
}

/**
 * @generated from message aiserver.v1.RepositoryStatusResponse.TooBig
 */
export class RepositoryStatusResponse_TooBig extends Message<RepositoryStatusResponse_TooBig> {
  /**
   * @generated from field: int32 max_size = 1;
   */
  maxSize = 0;

  constructor(data?: PartialMessage<RepositoryStatusResponse_TooBig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.RepositoryStatusResponse.TooBig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "max_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RepositoryStatusResponse_TooBig {
    return new RepositoryStatusResponse_TooBig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RepositoryStatusResponse_TooBig {
    return new RepositoryStatusResponse_TooBig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RepositoryStatusResponse_TooBig {
    return new RepositoryStatusResponse_TooBig().fromJsonString(jsonString, options);
  }

  static equals(a: RepositoryStatusResponse_TooBig | PlainMessage<RepositoryStatusResponse_TooBig> | undefined, b: RepositoryStatusResponse_TooBig | PlainMessage<RepositoryStatusResponse_TooBig> | undefined): boolean {
    return proto3.util.equals(RepositoryStatusResponse_TooBig, a, b);
  }
}

/**
 * @generated from message aiserver.v1.RepositoryStatusResponse.AuthTokenNotFound
 */
export class RepositoryStatusResponse_AuthTokenNotFound extends Message<RepositoryStatusResponse_AuthTokenNotFound> {
  constructor(data?: PartialMessage<RepositoryStatusResponse_AuthTokenNotFound>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.RepositoryStatusResponse.AuthTokenNotFound";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RepositoryStatusResponse_AuthTokenNotFound {
    return new RepositoryStatusResponse_AuthTokenNotFound().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RepositoryStatusResponse_AuthTokenNotFound {
    return new RepositoryStatusResponse_AuthTokenNotFound().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RepositoryStatusResponse_AuthTokenNotFound {
    return new RepositoryStatusResponse_AuthTokenNotFound().fromJsonString(jsonString, options);
  }

  static equals(a: RepositoryStatusResponse_AuthTokenNotFound | PlainMessage<RepositoryStatusResponse_AuthTokenNotFound> | undefined, b: RepositoryStatusResponse_AuthTokenNotFound | PlainMessage<RepositoryStatusResponse_AuthTokenNotFound> | undefined): boolean {
    return proto3.util.equals(RepositoryStatusResponse_AuthTokenNotFound, a, b);
  }
}

/**
 * @generated from message aiserver.v1.RepositoryStatusResponse.AuthTokenNotAuthorized
 */
export class RepositoryStatusResponse_AuthTokenNotAuthorized extends Message<RepositoryStatusResponse_AuthTokenNotAuthorized> {
  constructor(data?: PartialMessage<RepositoryStatusResponse_AuthTokenNotAuthorized>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.RepositoryStatusResponse.AuthTokenNotAuthorized";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RepositoryStatusResponse_AuthTokenNotAuthorized {
    return new RepositoryStatusResponse_AuthTokenNotAuthorized().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RepositoryStatusResponse_AuthTokenNotAuthorized {
    return new RepositoryStatusResponse_AuthTokenNotAuthorized().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RepositoryStatusResponse_AuthTokenNotAuthorized {
    return new RepositoryStatusResponse_AuthTokenNotAuthorized().fromJsonString(jsonString, options);
  }

  static equals(a: RepositoryStatusResponse_AuthTokenNotAuthorized | PlainMessage<RepositoryStatusResponse_AuthTokenNotAuthorized> | undefined, b: RepositoryStatusResponse_AuthTokenNotAuthorized | PlainMessage<RepositoryStatusResponse_AuthTokenNotAuthorized> | undefined): boolean {
    return proto3.util.equals(RepositoryStatusResponse_AuthTokenNotAuthorized, a, b);
  }
}

/**
 * @generated from message aiserver.v1.RepositoryStatusResponse.EmptyMessage
 */
export class RepositoryStatusResponse_EmptyMessage extends Message<RepositoryStatusResponse_EmptyMessage> {
  constructor(data?: PartialMessage<RepositoryStatusResponse_EmptyMessage>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.RepositoryStatusResponse.EmptyMessage";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RepositoryStatusResponse_EmptyMessage {
    return new RepositoryStatusResponse_EmptyMessage().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RepositoryStatusResponse_EmptyMessage {
    return new RepositoryStatusResponse_EmptyMessage().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RepositoryStatusResponse_EmptyMessage {
    return new RepositoryStatusResponse_EmptyMessage().fromJsonString(jsonString, options);
  }

  static equals(a: RepositoryStatusResponse_EmptyMessage | PlainMessage<RepositoryStatusResponse_EmptyMessage> | undefined, b: RepositoryStatusResponse_EmptyMessage | PlainMessage<RepositoryStatusResponse_EmptyMessage> | undefined): boolean {
    return proto3.util.equals(RepositoryStatusResponse_EmptyMessage, a, b);
  }
}

/**
 * TODO: you should be able to override / configure this list in your .vscode
 * settings not exactly sure what that should look like... but i guess you
 * should be able to specify an override URL because we use URLs for identifying
 * repos and maybe you should be able to specify additional buckets too... like
 * in the jane street case: i guess jane street should have some default buckets
 *
 * @generated from message aiserver.v1.RepositoryInfo
 */
export class RepositoryInfo extends Message<RepositoryInfo> {
  /**
   * the relative path in the current workspace
   * this is useful for locating the repo and identifying what repo a given file
   * is in this should be unique for different repositories (I think)
   *
   * @generated from field: string relative_workspace_path = 1;
   */
  relativeWorkspacePath = "";

  /**
   * a git repo may have multiple remotes
   * at the server we choose the remote (either origin, or the one we have
   * embedded, or something else) invariant: len(remote_urls) ==
   * len(remote_names)
   *
   * @generated from field: repeated string remote_urls = 2;
   */
  remoteUrls: string[] = [];

  /**
   * @generated from field: repeated string remote_names = 3;
   */
  remoteNames: string[] = [];

  /**
   * @generated from field: string repo_name = 4;
   */
  repoName = "";

  /**
   * @generated from field: string repo_owner = 5;
   */
  repoOwner = "";

  /**
   * @generated from field: bool is_tracked = 6;
   */
  isTracked = false;

  /**
   * If this is local
   *
   * @generated from field: bool is_local = 7;
   */
  isLocal = false;

  /**
   * number of files in the repo
   *
   * @generated from field: optional int32 num_files = 8;
   */
  numFiles?: number;

  constructor(data?: PartialMessage<RepositoryInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.RepositoryInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "remote_urls", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "remote_names", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "repo_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "repo_owner", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "is_tracked", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "is_local", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 8, name: "num_files", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RepositoryInfo {
    return new RepositoryInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RepositoryInfo {
    return new RepositoryInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RepositoryInfo {
    return new RepositoryInfo().fromJsonString(jsonString, options);
  }

  static equals(a: RepositoryInfo | PlainMessage<RepositoryInfo> | undefined, b: RepositoryInfo | PlainMessage<RepositoryInfo> | undefined): boolean {
    return proto3.util.equals(RepositoryInfo, a, b);
  }
}

/**
 * @generated from message aiserver.v1.SearchRepositoryDeepContextRequest
 */
export class SearchRepositoryDeepContextRequest extends Message<SearchRepositoryDeepContextRequest> {
  /**
   * @generated from field: string query = 1;
   */
  query = "";

  /**
   * @generated from field: int32 top_k = 2;
   */
  topK = 0;

  /**
   * @generated from field: int32 top_reflections_k = 3;
   */
  topReflectionsK = 0;

  /**
   * @generated from field: repeated string index_ids = 4;
   */
  indexIds: string[] = [];

  /**
   * @generated from field: bool use_model_on_files = 5;
   */
  useModelOnFiles = false;

  /**
   * @generated from field: bool use_reflections = 6;
   */
  useReflections = false;

  constructor(data?: PartialMessage<SearchRepositoryDeepContextRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.SearchRepositoryDeepContextRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "query", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "top_k", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "top_reflections_k", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "index_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "use_model_on_files", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "use_reflections", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchRepositoryDeepContextRequest {
    return new SearchRepositoryDeepContextRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchRepositoryDeepContextRequest {
    return new SearchRepositoryDeepContextRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchRepositoryDeepContextRequest {
    return new SearchRepositoryDeepContextRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SearchRepositoryDeepContextRequest | PlainMessage<SearchRepositoryDeepContextRequest> | undefined, b: SearchRepositoryDeepContextRequest | PlainMessage<SearchRepositoryDeepContextRequest> | undefined): boolean {
    return proto3.util.equals(SearchRepositoryDeepContextRequest, a, b);
  }
}

/**
 * @generated from message aiserver.v1.NodeResult
 */
export class NodeResult extends Message<NodeResult> {
  /**
   * @generated from field: aiserver.v1.IndexFileData.NodeData node = 1;
   */
  node?: IndexFileData_NodeData;

  /**
   * @generated from field: aiserver.v1.File file = 2;
   */
  file?: File;

  /**
   * @generated from field: float score = 3;
   */
  score = 0;

  constructor(data?: PartialMessage<NodeResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.NodeResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "node", kind: "message", T: IndexFileData_NodeData },
    { no: 2, name: "file", kind: "message", T: File },
    { no: 3, name: "score", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NodeResult {
    return new NodeResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NodeResult {
    return new NodeResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NodeResult {
    return new NodeResult().fromJsonString(jsonString, options);
  }

  static equals(a: NodeResult | PlainMessage<NodeResult> | undefined, b: NodeResult | PlainMessage<NodeResult> | undefined): boolean {
    return proto3.util.equals(NodeResult, a, b);
  }
}

/**
 * @generated from message aiserver.v1.ReflectionResult
 */
export class ReflectionResult extends Message<ReflectionResult> {
  /**
   * @generated from field: aiserver.v1.ReflectionData reflection = 1;
   */
  reflection?: ReflectionData;

  /**
   * @generated from field: float score = 2;
   */
  score = 0;

  constructor(data?: PartialMessage<ReflectionResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.ReflectionResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "reflection", kind: "message", T: ReflectionData },
    { no: 2, name: "score", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReflectionResult {
    return new ReflectionResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReflectionResult {
    return new ReflectionResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReflectionResult {
    return new ReflectionResult().fromJsonString(jsonString, options);
  }

  static equals(a: ReflectionResult | PlainMessage<ReflectionResult> | undefined, b: ReflectionResult | PlainMessage<ReflectionResult> | undefined): boolean {
    return proto3.util.equals(ReflectionResult, a, b);
  }
}

/**
 * @generated from message aiserver.v1.SearchRepositoryDeepContextResponse
 */
export class SearchRepositoryDeepContextResponse extends Message<SearchRepositoryDeepContextResponse> {
  /**
   * @generated from field: repeated aiserver.v1.NodeResult top_nodes = 1;
   */
  topNodes: NodeResult[] = [];

  /**
   * @generated from field: repeated aiserver.v1.ReflectionResult reflections = 2;
   */
  reflections: ReflectionResult[] = [];

  /**
   * @generated from field: string index_id = 3;
   */
  indexId = "";

  constructor(data?: PartialMessage<SearchRepositoryDeepContextResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.SearchRepositoryDeepContextResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "top_nodes", kind: "message", T: NodeResult, repeated: true },
    { no: 2, name: "reflections", kind: "message", T: ReflectionResult, repeated: true },
    { no: 3, name: "index_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchRepositoryDeepContextResponse {
    return new SearchRepositoryDeepContextResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchRepositoryDeepContextResponse {
    return new SearchRepositoryDeepContextResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchRepositoryDeepContextResponse {
    return new SearchRepositoryDeepContextResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SearchRepositoryDeepContextResponse | PlainMessage<SearchRepositoryDeepContextResponse> | undefined, b: SearchRepositoryDeepContextResponse | PlainMessage<SearchRepositoryDeepContextResponse> | undefined): boolean {
    return proto3.util.equals(SearchRepositoryDeepContextResponse, a, b);
  }
}

