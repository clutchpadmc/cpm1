// @generated by protoc-gen-es v1.2.1 with parameter "target=ts"
// @generated from file aiserver/v1/lint.proto (package aiserver.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { SimpleRange } from './utils_pb';

/**
 * @generated from enum aiserver.v1.LintDiscriminator
 */
export enum LintDiscriminator {
  /**
   * @generated from enum value: LINT_DISCRIMINATOR_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: LINT_DISCRIMINATOR_SPECIFIC_RULES = 1;
   */
  SPECIFIC_RULES = 1,

  /**
   * @generated from enum value: LINT_DISCRIMINATOR_COMPILE_ERRORS = 2;
   */
  COMPILE_ERRORS = 2,

  /**
   * @generated from enum value: LINT_DISCRIMINATOR_CHANGE_BEHAVIOR = 3;
   */
  CHANGE_BEHAVIOR = 3,

  /**
   * @generated from enum value: LINT_DISCRIMINATOR_RELEVANCE = 5;
   */
  RELEVANCE = 5,

  /**
   * @generated from enum value: LINT_DISCRIMINATOR_USER_AWARENESS = 6;
   */
  USER_AWARENESS = 6,

  /**
   * @generated from enum value: LINT_DISCRIMINATOR_CORRECTNESS = 7;
   */
  CORRECTNESS = 7,

  /**
   * @generated from enum value: LINT_DISCRIMINATOR_CHUNKING = 8;
   */
  CHUNKING = 8,

  /**
   * @generated from enum value: LINT_DISCRIMINATOR_TYPO = 9;
   */
  TYPO = 9,

  /**
   * @generated from enum value: LINT_DISCRIMINATOR_CONFIDENCE = 10;
   */
  CONFIDENCE = 10,

  /**
   * @generated from enum value: LINT_DISCRIMINATOR_DISMISSED_BUGS = 11;
   */
  DISMISSED_BUGS = 11,
}
// Retrieve enum metadata with: proto3.getEnumType(LintDiscriminator)
proto3.util.setEnumType(LintDiscriminator, "aiserver.v1.LintDiscriminator", [
  { no: 0, name: "LINT_DISCRIMINATOR_UNSPECIFIED" },
  { no: 1, name: "LINT_DISCRIMINATOR_SPECIFIC_RULES" },
  { no: 2, name: "LINT_DISCRIMINATOR_COMPILE_ERRORS" },
  { no: 3, name: "LINT_DISCRIMINATOR_CHANGE_BEHAVIOR" },
  { no: 5, name: "LINT_DISCRIMINATOR_RELEVANCE" },
  { no: 6, name: "LINT_DISCRIMINATOR_USER_AWARENESS" },
  { no: 7, name: "LINT_DISCRIMINATOR_CORRECTNESS" },
  { no: 8, name: "LINT_DISCRIMINATOR_CHUNKING" },
  { no: 9, name: "LINT_DISCRIMINATOR_TYPO" },
  { no: 10, name: "LINT_DISCRIMINATOR_CONFIDENCE" },
  { no: 11, name: "LINT_DISCRIMINATOR_DISMISSED_BUGS" },
]);

/**
 * @generated from enum aiserver.v1.LintGenerator
 */
export enum LintGenerator {
  /**
   * @generated from enum value: LINT_GENERATOR_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: LINT_GENERATOR_NAIVE = 1;
   */
  NAIVE = 1,

  /**
   * @generated from enum value: LINT_GENERATOR_COMMENT_PIPELINE = 2;
   */
  COMMENT_PIPELINE = 2,

  /**
   * @generated from enum value: LINT_GENERATOR_SIMPLE_BUG = 3;
   */
  SIMPLE_BUG = 3,

  /**
   * @generated from enum value: LINT_GENERATOR_SIMPLE_LINT_RULES = 4;
   */
  SIMPLE_LINT_RULES = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(LintGenerator)
proto3.util.setEnumType(LintGenerator, "aiserver.v1.LintGenerator", [
  { no: 0, name: "LINT_GENERATOR_UNSPECIFIED" },
  { no: 1, name: "LINT_GENERATOR_NAIVE" },
  { no: 2, name: "LINT_GENERATOR_COMMENT_PIPELINE" },
  { no: 3, name: "LINT_GENERATOR_SIMPLE_BUG" },
  { no: 4, name: "LINT_GENERATOR_SIMPLE_LINT_RULES" },
]);

/**
 * @generated from message aiserver.v1.LintDiscriminatorResult
 */
export class LintDiscriminatorResult extends Message<LintDiscriminatorResult> {
  /**
   * @generated from field: aiserver.v1.LintDiscriminator discriminator = 1;
   */
  discriminator = LintDiscriminator.UNSPECIFIED;

  /**
   * whether the bug is allowed to pass or not
   *
   * @generated from field: bool allow = 2;
   */
  allow = false;

  /**
   * optional reasoning
   *
   * @generated from field: string reasoning = 3;
   */
  reasoning = "";

  constructor(data?: PartialMessage<LintDiscriminatorResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.LintDiscriminatorResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "discriminator", kind: "enum", T: proto3.getEnumType(LintDiscriminator) },
    { no: 2, name: "allow", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "reasoning", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LintDiscriminatorResult {
    return new LintDiscriminatorResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LintDiscriminatorResult {
    return new LintDiscriminatorResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LintDiscriminatorResult {
    return new LintDiscriminatorResult().fromJsonString(jsonString, options);
  }

  static equals(a: LintDiscriminatorResult | PlainMessage<LintDiscriminatorResult> | undefined, b: LintDiscriminatorResult | PlainMessage<LintDiscriminatorResult> | undefined): boolean {
    return proto3.util.equals(LintDiscriminatorResult, a, b);
  }
}

/**
 * @generated from message aiserver.v1.AiLintBug
 */
export class AiLintBug extends Message<AiLintBug> {
  /**
   * @generated from field: string relative_workspace_path = 1;
   */
  relativeWorkspacePath = "";

  /**
   * @generated from field: string uuid = 8;
   */
  uuid = "";

  /**
   * should be very concise
   *
   * @generated from field: string message = 2;
   */
  message = "";

  /**
   * @generated from field: aiserver.v1.SimpleRange replace_range = 3;
   */
  replaceRange?: SimpleRange;

  /**
   * @generated from field: string replace_text = 4;
   */
  replaceText = "";

  /**
   * the text in the replace range initially (so we can check for changes)
   *
   * @generated from field: string replace_initial_text = 5;
   */
  replaceInitialText = "";

  /**
   * if in the reevaluate_range, the bug should be reevaluated by asking the AI
   * it may have disappeared
   *
   * @generated from field: aiserver.v1.SimpleRange reevaluate_range = 6;
   */
  reevaluateRange?: SimpleRange;

  /**
   * the text in the reevaluate_range initially (so we can check for changes)
   *
   * @generated from field: string reevaluate_initial_text = 7;
   */
  reevaluateInitialText = "";

  /**
   * we keep track of which generator created this bug, as well as the status of each discriminator
   *
   * @generated from field: aiserver.v1.LintGenerator generator = 9;
   */
  generator = LintGenerator.UNSPECIFIED;

  /**
   * we also keep track of lint discriminators
   *
   * @generated from field: repeated aiserver.v1.LintDiscriminatorResult discriminator_results = 10;
   */
  discriminatorResults: LintDiscriminatorResult[] = [];

  constructor(data?: PartialMessage<AiLintBug>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.AiLintBug";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "uuid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "replace_range", kind: "message", T: SimpleRange },
    { no: 4, name: "replace_text", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "replace_initial_text", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "reevaluate_range", kind: "message", T: SimpleRange },
    { no: 7, name: "reevaluate_initial_text", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "generator", kind: "enum", T: proto3.getEnumType(LintGenerator) },
    { no: 10, name: "discriminator_results", kind: "message", T: LintDiscriminatorResult, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AiLintBug {
    return new AiLintBug().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AiLintBug {
    return new AiLintBug().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AiLintBug {
    return new AiLintBug().fromJsonString(jsonString, options);
  }

  static equals(a: AiLintBug | PlainMessage<AiLintBug> | undefined, b: AiLintBug | PlainMessage<AiLintBug> | undefined): boolean {
    return proto3.util.equals(AiLintBug, a, b);
  }
}

/**
 * @generated from message aiserver.v1.AiLintInlineSuggestion
 */
export class AiLintInlineSuggestion extends Message<AiLintInlineSuggestion> {
  /**
   * @generated from field: string relative_workspace_path = 1;
   */
  relativeWorkspacePath = "";

  /**
   * @generated from field: string uuid = 8;
   */
  uuid = "";

  /**
   * needs to be very concise, again!
   *
   * @generated from field: string message = 2;
   */
  message = "";

  /**
   * @generated from field: int32 line_number = 3;
   */
  lineNumber = 0;

  /**
   * if in the reevaluate_range, the bug should be reevaluated by asking the AI
   * it may have disappeared
   *
   * @generated from field: aiserver.v1.SimpleRange reevaluate_range = 4;
   */
  reevaluateRange?: SimpleRange;

  /**
   * the text in the reevaluate_range initially (so we can check for changes)
   *
   * @generated from field: string reevaluate_initial_text = 5;
   */
  reevaluateInitialText = "";

  constructor(data?: PartialMessage<AiLintInlineSuggestion>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.AiLintInlineSuggestion";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "uuid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "line_number", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "reevaluate_range", kind: "message", T: SimpleRange },
    { no: 5, name: "reevaluate_initial_text", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AiLintInlineSuggestion {
    return new AiLintInlineSuggestion().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AiLintInlineSuggestion {
    return new AiLintInlineSuggestion().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AiLintInlineSuggestion {
    return new AiLintInlineSuggestion().fromJsonString(jsonString, options);
  }

  static equals(a: AiLintInlineSuggestion | PlainMessage<AiLintInlineSuggestion> | undefined, b: AiLintInlineSuggestion | PlainMessage<AiLintInlineSuggestion> | undefined): boolean {
    return proto3.util.equals(AiLintInlineSuggestion, a, b);
  }
}

/**
 * @generated from message aiserver.v1.AiLintOutOfFlowSuggestion
 */
export class AiLintOutOfFlowSuggestion extends Message<AiLintOutOfFlowSuggestion> {
  /**
   * @generated from field: string relative_workspace_path = 1;
   */
  relativeWorkspacePath = "";

  /**
   * @generated from field: string uuid = 8;
   */
  uuid = "";

  /**
   * @generated from field: string message = 2;
   */
  message = "";

  constructor(data?: PartialMessage<AiLintOutOfFlowSuggestion>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.AiLintOutOfFlowSuggestion";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "uuid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AiLintOutOfFlowSuggestion {
    return new AiLintOutOfFlowSuggestion().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AiLintOutOfFlowSuggestion {
    return new AiLintOutOfFlowSuggestion().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AiLintOutOfFlowSuggestion {
    return new AiLintOutOfFlowSuggestion().fromJsonString(jsonString, options);
  }

  static equals(a: AiLintOutOfFlowSuggestion | PlainMessage<AiLintOutOfFlowSuggestion> | undefined, b: AiLintOutOfFlowSuggestion | PlainMessage<AiLintOutOfFlowSuggestion> | undefined): boolean {
    return proto3.util.equals(AiLintOutOfFlowSuggestion, a, b);
  }
}

/**
 * @generated from message aiserver.v1.AiLintRule
 */
export class AiLintRule extends Message<AiLintRule> {
  /**
   * @generated from field: string text = 1;
   */
  text = "";

  constructor(data?: PartialMessage<AiLintRule>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.AiLintRule";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "text", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AiLintRule {
    return new AiLintRule().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AiLintRule {
    return new AiLintRule().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AiLintRule {
    return new AiLintRule().fromJsonString(jsonString, options);
  }

  static equals(a: AiLintRule | PlainMessage<AiLintRule> | undefined, b: AiLintRule | PlainMessage<AiLintRule> | undefined): boolean {
    return proto3.util.equals(AiLintRule, a, b);
  }
}

