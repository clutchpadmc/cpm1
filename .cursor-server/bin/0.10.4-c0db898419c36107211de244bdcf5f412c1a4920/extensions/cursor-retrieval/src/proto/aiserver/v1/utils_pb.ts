// @generated by protoc-gen-es v1.2.1 with parameter "target=ts"
// @generated from file aiserver/v1/utils.proto (package aiserver.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * should correspond to the MarkerSeverity symbol in vscode
 *
 * @generated from enum aiserver.v1.LintSeverity
 */
export enum LintSeverity {
  /**
   * @generated from enum value: LINT_SEVERITY_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: LINT_SEVERITY_ERROR = 1;
   */
  ERROR = 1,

  /**
   * @generated from enum value: LINT_SEVERITY_WARNING = 2;
   */
  WARNING = 2,

  /**
   * @generated from enum value: LINT_SEVERITY_INFO = 3;
   */
  INFO = 3,

  /**
   * @generated from enum value: LINT_SEVERITY_HINT = 4;
   */
  HINT = 4,

  /**
   * @generated from enum value: LINT_SEVERITY_AI = 5;
   */
  AI = 5,
}
// Retrieve enum metadata with: proto3.getEnumType(LintSeverity)
proto3.util.setEnumType(LintSeverity, "aiserver.v1.LintSeverity", [
  { no: 0, name: "LINT_SEVERITY_UNSPECIFIED" },
  { no: 1, name: "LINT_SEVERITY_ERROR" },
  { no: 2, name: "LINT_SEVERITY_WARNING" },
  { no: 3, name: "LINT_SEVERITY_INFO" },
  { no: 4, name: "LINT_SEVERITY_HINT" },
  { no: 5, name: "LINT_SEVERITY_AI" },
]);

/**
 * @generated from enum aiserver.v1.FeatureType
 */
export enum FeatureType {
  /**
   * @generated from enum value: FEATURE_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: FEATURE_TYPE_EDIT = 1;
   */
  EDIT = 1,

  /**
   * @generated from enum value: FEATURE_TYPE_GENERATE = 2;
   */
  GENERATE = 2,

  /**
   * @generated from enum value: FEATURE_TYPE_INLINE_LONG_COMPLETION = 3;
   */
  INLINE_LONG_COMPLETION = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(FeatureType)
proto3.util.setEnumType(FeatureType, "aiserver.v1.FeatureType", [
  { no: 0, name: "FEATURE_TYPE_UNSPECIFIED" },
  { no: 1, name: "FEATURE_TYPE_EDIT" },
  { no: 2, name: "FEATURE_TYPE_GENERATE" },
  { no: 3, name: "FEATURE_TYPE_INLINE_LONG_COMPLETION" },
]);

/**
 * The positions here are unfortunately actually 0-indexed due to a bug and
 * has kept this way for backwards compatibility
 *
 * @generated from message aiserver.v1.CursorPosition
 */
export class CursorPosition extends Message<CursorPosition> {
  /**
   * the line number is 0-indexed
   *
   * @generated from field: int32 line = 1;
   */
  line = 0;

  /**
   * the column number is 0-indexed
   *
   * @generated from field: int32 column = 2;
   */
  column = 0;

  constructor(data?: PartialMessage<CursorPosition>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.CursorPosition";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "line", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "column", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CursorPosition {
    return new CursorPosition().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CursorPosition {
    return new CursorPosition().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CursorPosition {
    return new CursorPosition().fromJsonString(jsonString, options);
  }

  static equals(a: CursorPosition | PlainMessage<CursorPosition> | undefined, b: CursorPosition | PlainMessage<CursorPosition> | undefined): boolean {
    return proto3.util.equals(CursorPosition, a, b);
  }
}

/**
 * @generated from message aiserver.v1.SimpleRange
 */
export class SimpleRange extends Message<SimpleRange> {
  /**
   * 1-indexed
   *
   * @generated from field: int32 start_line_number = 1;
   */
  startLineNumber = 0;

  /**
   * 1-indexed
   *
   * @generated from field: int32 start_column = 2;
   */
  startColumn = 0;

  /**
   * 1-indexed
   *
   * @generated from field: int32 end_line_number_inclusive = 3;
   */
  endLineNumberInclusive = 0;

  /**
   * 1-indexed
   *
   * @generated from field: int32 end_column = 4;
   */
  endColumn = 0;

  constructor(data?: PartialMessage<SimpleRange>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.SimpleRange";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "start_line_number", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "start_column", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "end_line_number_inclusive", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "end_column", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SimpleRange {
    return new SimpleRange().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SimpleRange {
    return new SimpleRange().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SimpleRange {
    return new SimpleRange().fromJsonString(jsonString, options);
  }

  static equals(a: SimpleRange | PlainMessage<SimpleRange> | undefined, b: SimpleRange | PlainMessage<SimpleRange> | undefined): boolean {
    return proto3.util.equals(SimpleRange, a, b);
  }
}

/**
 * @generated from message aiserver.v1.LineRange
 */
export class LineRange extends Message<LineRange> {
  /**
   * 1-indexed
   *
   * @generated from field: int32 start_line_number = 1;
   */
  startLineNumber = 0;

  /**
   * 1-indexed
   *
   * @generated from field: int32 end_line_number_inclusive = 2;
   */
  endLineNumberInclusive = 0;

  constructor(data?: PartialMessage<LineRange>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.LineRange";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "start_line_number", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "end_line_number_inclusive", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LineRange {
    return new LineRange().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LineRange {
    return new LineRange().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LineRange {
    return new LineRange().fromJsonString(jsonString, options);
  }

  static equals(a: LineRange | PlainMessage<LineRange> | undefined, b: LineRange | PlainMessage<LineRange> | undefined): boolean {
    return proto3.util.equals(LineRange, a, b);
  }
}

/**
 * a single cursor (not a selection) has start_position == end_position
 * that should tell you everything you need to know
 * cursor range is DEPRECATED. for any new ranges, please use SimpleRange or LineRange above
 * (cursor range is 0-indexed, which is bad, and also the doubly nested structured is annoying because of null checks)
 *
 * @generated from message aiserver.v1.CursorRange
 */
export class CursorRange extends Message<CursorRange> {
  /**
   * start_position is inclusive
   *
   * @generated from field: aiserver.v1.CursorPosition start_position = 1;
   */
  startPosition?: CursorPosition;

  /**
   * end_position is exclusive!
   *
   * @generated from field: aiserver.v1.CursorPosition end_position = 2;
   */
  endPosition?: CursorPosition;

  constructor(data?: PartialMessage<CursorRange>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.CursorRange";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "start_position", kind: "message", T: CursorPosition },
    { no: 2, name: "end_position", kind: "message", T: CursorPosition },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CursorRange {
    return new CursorRange().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CursorRange {
    return new CursorRange().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CursorRange {
    return new CursorRange().fromJsonString(jsonString, options);
  }

  static equals(a: CursorRange | PlainMessage<CursorRange> | undefined, b: CursorRange | PlainMessage<CursorRange> | undefined): boolean {
    return proto3.util.equals(CursorRange, a, b);
  }
}

/**
 * / General info on a codeblock
 *
 * @generated from message aiserver.v1.CodeBlock
 */
export class CodeBlock extends Message<CodeBlock> {
  /**
   * @generated from field: string relative_workspace_path = 1;
   */
  relativeWorkspacePath = "";

  /**
   * @generated from field: optional string file_contents = 2;
   */
  fileContents?: string;

  /**
   * @generated from field: aiserver.v1.CursorRange range = 3;
   */
  range?: CursorRange;

  /**
   * @generated from field: string contents = 4;
   */
  contents = "";

  /**
   * @generated from field: aiserver.v1.CodeBlock.Signatures signatures = 5;
   */
  signatures?: CodeBlock_Signatures;

  constructor(data?: PartialMessage<CodeBlock>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.CodeBlock";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "file_contents", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "range", kind: "message", T: CursorRange },
    { no: 4, name: "contents", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "signatures", kind: "message", T: CodeBlock_Signatures },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CodeBlock {
    return new CodeBlock().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CodeBlock {
    return new CodeBlock().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CodeBlock {
    return new CodeBlock().fromJsonString(jsonString, options);
  }

  static equals(a: CodeBlock | PlainMessage<CodeBlock> | undefined, b: CodeBlock | PlainMessage<CodeBlock> | undefined): boolean {
    return proto3.util.equals(CodeBlock, a, b);
  }
}

/**
 * @generated from message aiserver.v1.CodeBlock.Signatures
 */
export class CodeBlock_Signatures extends Message<CodeBlock_Signatures> {
  /**
   * @generated from field: repeated aiserver.v1.CursorRange ranges = 1;
   */
  ranges: CursorRange[] = [];

  constructor(data?: PartialMessage<CodeBlock_Signatures>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.CodeBlock.Signatures";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ranges", kind: "message", T: CursorRange, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CodeBlock_Signatures {
    return new CodeBlock_Signatures().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CodeBlock_Signatures {
    return new CodeBlock_Signatures().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CodeBlock_Signatures {
    return new CodeBlock_Signatures().fromJsonString(jsonString, options);
  }

  static equals(a: CodeBlock_Signatures | PlainMessage<CodeBlock_Signatures> | undefined, b: CodeBlock_Signatures | PlainMessage<CodeBlock_Signatures> | undefined): boolean {
    return proto3.util.equals(CodeBlock_Signatures, a, b);
  }
}

/**
 * @generated from message aiserver.v1.File
 */
export class File extends Message<File> {
  /**
   * @generated from field: string relative_workspace_path = 1;
   */
  relativeWorkspacePath = "";

  /**
   * @generated from field: string contents = 2;
   */
  contents = "";

  constructor(data?: PartialMessage<File>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.File";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "contents", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): File {
    return new File().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): File {
    return new File().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): File {
    return new File().fromJsonString(jsonString, options);
  }

  static equals(a: File | PlainMessage<File> | undefined, b: File | PlainMessage<File> | undefined): boolean {
    return proto3.util.equals(File, a, b);
  }
}

/**
 * @generated from message aiserver.v1.Diagnostic
 */
export class Diagnostic extends Message<Diagnostic> {
  /**
   * @generated from field: string message = 1;
   */
  message = "";

  /**
   * @generated from field: aiserver.v1.CursorRange range = 2;
   */
  range?: CursorRange;

  /**
   * @generated from field: aiserver.v1.Diagnostic.DiagnosticSeverity severity = 3;
   */
  severity = Diagnostic_DiagnosticSeverity.UNSPECIFIED;

  constructor(data?: PartialMessage<Diagnostic>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.Diagnostic";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "range", kind: "message", T: CursorRange },
    { no: 3, name: "severity", kind: "enum", T: proto3.getEnumType(Diagnostic_DiagnosticSeverity) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Diagnostic {
    return new Diagnostic().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Diagnostic {
    return new Diagnostic().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Diagnostic {
    return new Diagnostic().fromJsonString(jsonString, options);
  }

  static equals(a: Diagnostic | PlainMessage<Diagnostic> | undefined, b: Diagnostic | PlainMessage<Diagnostic> | undefined): boolean {
    return proto3.util.equals(Diagnostic, a, b);
  }
}

/**
 * @generated from enum aiserver.v1.Diagnostic.DiagnosticSeverity
 */
export enum Diagnostic_DiagnosticSeverity {
  /**
   * @generated from enum value: DIAGNOSTIC_SEVERITY_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: DIAGNOSTIC_SEVERITY_ERROR = 1;
   */
  ERROR = 1,

  /**
   * @generated from enum value: DIAGNOSTIC_SEVERITY_WARNING = 2;
   */
  WARNING = 2,

  /**
   * @generated from enum value: DIAGNOSTIC_SEVERITY_INFORMATION = 3;
   */
  INFORMATION = 3,

  /**
   * @generated from enum value: DIAGNOSTIC_SEVERITY_HINT = 4;
   */
  HINT = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(Diagnostic_DiagnosticSeverity)
proto3.util.setEnumType(Diagnostic_DiagnosticSeverity, "aiserver.v1.Diagnostic.DiagnosticSeverity", [
  { no: 0, name: "DIAGNOSTIC_SEVERITY_UNSPECIFIED" },
  { no: 1, name: "DIAGNOSTIC_SEVERITY_ERROR" },
  { no: 2, name: "DIAGNOSTIC_SEVERITY_WARNING" },
  { no: 3, name: "DIAGNOSTIC_SEVERITY_INFORMATION" },
  { no: 4, name: "DIAGNOSTIC_SEVERITY_HINT" },
]);

/**
 * we have a separate Lint message because the Diagnostic uses the deprecated CursorRange
 *
 * @generated from message aiserver.v1.Lint
 */
export class Lint extends Message<Lint> {
  /**
   * @generated from field: string message = 1;
   */
  message = "";

  /**
   * @generated from field: aiserver.v1.SimpleRange range = 2;
   */
  range?: SimpleRange;

  /**
   * @generated from field: aiserver.v1.LintSeverity severity = 3;
   */
  severity = LintSeverity.UNSPECIFIED;

  constructor(data?: PartialMessage<Lint>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.Lint";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "range", kind: "message", T: SimpleRange },
    { no: 3, name: "severity", kind: "enum", T: proto3.getEnumType(LintSeverity) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Lint {
    return new Lint().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Lint {
    return new Lint().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Lint {
    return new Lint().fromJsonString(jsonString, options);
  }

  static equals(a: Lint | PlainMessage<Lint> | undefined, b: Lint | PlainMessage<Lint> | undefined): boolean {
    return proto3.util.equals(Lint, a, b);
  }
}

/**
 * @generated from message aiserver.v1.CurrentFileInfo
 */
export class CurrentFileInfo extends Message<CurrentFileInfo> {
  /**
   * the relative path in the current workspace
   *
   * @generated from field: string relative_workspace_path = 1;
   */
  relativeWorkspacePath = "";

  /**
   * TODO: support both text files and notebook files
   * TODO: maybe we don't need to send up the entire file if we have a file sync
   * server?
   *
   * @generated from field: string contents = 2;
   */
  contents = "";

  /**
   * @generated from field: aiserver.v1.CursorPosition cursor_position = 3;
   */
  cursorPosition?: CursorPosition;

  /**
   * dataframes only exist in notebooks
   *
   * @generated from field: repeated aiserver.v1.DataframeInfo dataframes = 4;
   */
  dataframes: DataframeInfo[] = [];

  /**
   * @generated from field: string language_id = 5;
   */
  languageId = "";

  /**
   * TODO: support multiple selections
   *
   * @generated from field: aiserver.v1.CursorRange selection = 6;
   */
  selection?: CursorRange;

  /**
   * @generated from field: repeated aiserver.v1.Diagnostic diagnostics = 7;
   */
  diagnostics: Diagnostic[] = [];

  constructor(data?: PartialMessage<CurrentFileInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.CurrentFileInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "contents", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "cursor_position", kind: "message", T: CursorPosition },
    { no: 4, name: "dataframes", kind: "message", T: DataframeInfo, repeated: true },
    { no: 5, name: "language_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "selection", kind: "message", T: CursorRange },
    { no: 7, name: "diagnostics", kind: "message", T: Diagnostic, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CurrentFileInfo {
    return new CurrentFileInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CurrentFileInfo {
    return new CurrentFileInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CurrentFileInfo {
    return new CurrentFileInfo().fromJsonString(jsonString, options);
  }

  static equals(a: CurrentFileInfo | PlainMessage<CurrentFileInfo> | undefined, b: CurrentFileInfo | PlainMessage<CurrentFileInfo> | undefined): boolean {
    return proto3.util.equals(CurrentFileInfo, a, b);
  }
}

/**
 * @generated from message aiserver.v1.AzureState
 */
export class AzureState extends Message<AzureState> {
  /**
   * @generated from field: string api_key = 1;
   */
  apiKey = "";

  /**
   * @generated from field: string base_url = 2;
   */
  baseUrl = "";

  /**
   * @generated from field: string deployment = 3;
   */
  deployment = "";

  /**
   * @generated from field: bool use_azure = 4;
   */
  useAzure = false;

  constructor(data?: PartialMessage<AzureState>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.AzureState";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "api_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "base_url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "deployment", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "use_azure", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AzureState {
    return new AzureState().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AzureState {
    return new AzureState().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AzureState {
    return new AzureState().fromJsonString(jsonString, options);
  }

  static equals(a: AzureState | PlainMessage<AzureState> | undefined, b: AzureState | PlainMessage<AzureState> | undefined): boolean {
    return proto3.util.equals(AzureState, a, b);
  }
}

/**
 * @generated from message aiserver.v1.ModelDetails
 */
export class ModelDetails extends Message<ModelDetails> {
  /**
   * @generated from field: optional string model_name = 1;
   */
  modelName?: string;

  /**
   * @generated from field: optional string api_key = 2;
   */
  apiKey?: string;

  /**
   * @generated from field: optional bool enable_ghost_mode = 3;
   */
  enableGhostMode?: boolean;

  /**
   * @generated from field: optional aiserver.v1.AzureState azure_state = 4;
   */
  azureState?: AzureState;

  constructor(data?: PartialMessage<ModelDetails>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.ModelDetails";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "model_name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "api_key", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "enable_ghost_mode", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 4, name: "azure_state", kind: "message", T: AzureState, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ModelDetails {
    return new ModelDetails().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ModelDetails {
    return new ModelDetails().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ModelDetails {
    return new ModelDetails().fromJsonString(jsonString, options);
  }

  static equals(a: ModelDetails | PlainMessage<ModelDetails> | undefined, b: ModelDetails | PlainMessage<ModelDetails> | undefined): boolean {
    return proto3.util.equals(ModelDetails, a, b);
  }
}

/**
 * @generated from message aiserver.v1.DataframeInfo
 */
export class DataframeInfo extends Message<DataframeInfo> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: string shape = 2;
   */
  shape = "";

  /**
   * @generated from field: int32 data_dimensionality = 3;
   */
  dataDimensionality = 0;

  /**
   * @generated from field: repeated aiserver.v1.DataframeInfo.Column columns = 6;
   */
  columns: DataframeInfo_Column[] = [];

  /**
   * @generated from field: int32 row_count = 7;
   */
  rowCount = 0;

  /**
   * @generated from field: string index_column = 8;
   */
  indexColumn = "";

  constructor(data?: PartialMessage<DataframeInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.DataframeInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "shape", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "data_dimensionality", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 6, name: "columns", kind: "message", T: DataframeInfo_Column, repeated: true },
    { no: 7, name: "row_count", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 8, name: "index_column", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DataframeInfo {
    return new DataframeInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DataframeInfo {
    return new DataframeInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DataframeInfo {
    return new DataframeInfo().fromJsonString(jsonString, options);
  }

  static equals(a: DataframeInfo | PlainMessage<DataframeInfo> | undefined, b: DataframeInfo | PlainMessage<DataframeInfo> | undefined): boolean {
    return proto3.util.equals(DataframeInfo, a, b);
  }
}

/**
 * @generated from message aiserver.v1.DataframeInfo.Column
 */
export class DataframeInfo_Column extends Message<DataframeInfo_Column> {
  /**
   * @generated from field: string key = 1;
   */
  key = "";

  /**
   * @generated from field: string type = 2;
   */
  type = "";

  constructor(data?: PartialMessage<DataframeInfo_Column>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.DataframeInfo.Column";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DataframeInfo_Column {
    return new DataframeInfo_Column().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DataframeInfo_Column {
    return new DataframeInfo_Column().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DataframeInfo_Column {
    return new DataframeInfo_Column().fromJsonString(jsonString, options);
  }

  static equals(a: DataframeInfo_Column | PlainMessage<DataframeInfo_Column> | undefined, b: DataframeInfo_Column | PlainMessage<DataframeInfo_Column> | undefined): boolean {
    return proto3.util.equals(DataframeInfo_Column, a, b);
  }
}

/**
 * @generated from message aiserver.v1.LinterError
 */
export class LinterError extends Message<LinterError> {
  /**
   * @generated from field: string message = 1;
   */
  message = "";

  /**
   * @generated from field: aiserver.v1.CursorRange range = 2;
   */
  range?: CursorRange;

  constructor(data?: PartialMessage<LinterError>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.LinterError";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "range", kind: "message", T: CursorRange },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LinterError {
    return new LinterError().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LinterError {
    return new LinterError().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LinterError {
    return new LinterError().fromJsonString(jsonString, options);
  }

  static equals(a: LinterError | PlainMessage<LinterError> | undefined, b: LinterError | PlainMessage<LinterError> | undefined): boolean {
    return proto3.util.equals(LinterError, a, b);
  }
}

/**
 * @generated from message aiserver.v1.LinterErrors
 */
export class LinterErrors extends Message<LinterErrors> {
  /**
   * @generated from field: string relative_workspace_path = 1;
   */
  relativeWorkspacePath = "";

  /**
   * @generated from field: repeated aiserver.v1.LinterError errors = 2;
   */
  errors: LinterError[] = [];

  /**
   * @generated from field: string file_contents = 3;
   */
  fileContents = "";

  constructor(data?: PartialMessage<LinterErrors>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.LinterErrors";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "errors", kind: "message", T: LinterError, repeated: true },
    { no: 3, name: "file_contents", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LinterErrors {
    return new LinterErrors().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LinterErrors {
    return new LinterErrors().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LinterErrors {
    return new LinterErrors().fromJsonString(jsonString, options);
  }

  static equals(a: LinterErrors | PlainMessage<LinterErrors> | undefined, b: LinterErrors | PlainMessage<LinterErrors> | undefined): boolean {
    return proto3.util.equals(LinterErrors, a, b);
  }
}

/**
 * TODO: this should be more complicated
 * it should contain a bunch more things, etc
 * the explicit context is all the stuff that the user explicitly provides, and
 * could be strings like "never use unwrap" or other things like selecting files
 * or links etc
 *
 * @generated from message aiserver.v1.ExplicitContext
 */
export class ExplicitContext extends Message<ExplicitContext> {
  /**
   * @generated from field: string context = 1;
   */
  context = "";

  constructor(data?: PartialMessage<ExplicitContext>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.ExplicitContext";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "context", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExplicitContext {
    return new ExplicitContext().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExplicitContext {
    return new ExplicitContext().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExplicitContext {
    return new ExplicitContext().fromJsonString(jsonString, options);
  }

  static equals(a: ExplicitContext | PlainMessage<ExplicitContext> | undefined, b: ExplicitContext | PlainMessage<ExplicitContext> | undefined): boolean {
    return proto3.util.equals(ExplicitContext, a, b);
  }
}

/**
 * @generated from message aiserver.v1.PureMessage
 */
export class PureMessage extends Message<PureMessage> {
  /**
   * @generated from field: aiserver.v1.PureMessage.MessageType message_type = 1;
   */
  messageType = PureMessage_MessageType.UNSPECIFIED;

  /**
   * @generated from field: string content = 2;
   */
  content = "";

  constructor(data?: PartialMessage<PureMessage>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.PureMessage";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "message_type", kind: "enum", T: proto3.getEnumType(PureMessage_MessageType) },
    { no: 2, name: "content", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PureMessage {
    return new PureMessage().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PureMessage {
    return new PureMessage().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PureMessage {
    return new PureMessage().fromJsonString(jsonString, options);
  }

  static equals(a: PureMessage | PlainMessage<PureMessage> | undefined, b: PureMessage | PlainMessage<PureMessage> | undefined): boolean {
    return proto3.util.equals(PureMessage, a, b);
  }
}

/**
 * @generated from enum aiserver.v1.PureMessage.MessageType
 */
export enum PureMessage_MessageType {
  /**
   * @generated from enum value: MESSAGE_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: MESSAGE_TYPE_SYSTEM = 1;
   */
  SYSTEM = 1,

  /**
   * @generated from enum value: MESSAGE_TYPE_USER = 2;
   */
  USER = 2,

  /**
   * @generated from enum value: MESSAGE_TYPE_ASSISTANT = 3;
   */
  ASSISTANT = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(PureMessage_MessageType)
proto3.util.setEnumType(PureMessage_MessageType, "aiserver.v1.PureMessage.MessageType", [
  { no: 0, name: "MESSAGE_TYPE_UNSPECIFIED" },
  { no: 1, name: "MESSAGE_TYPE_SYSTEM" },
  { no: 2, name: "MESSAGE_TYPE_USER" },
  { no: 3, name: "MESSAGE_TYPE_ASSISTANT" },
]);

/**
 * @generated from message aiserver.v1.DocumentSymbol
 */
export class DocumentSymbol extends Message<DocumentSymbol> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: string detail = 2;
   */
  detail = "";

  /**
   * @generated from field: aiserver.v1.DocumentSymbol.SymbolKind kind = 3;
   */
  kind = DocumentSymbol_SymbolKind.UNSPECIFIED;

  /**
   * @generated from field: string container_name = 5;
   */
  containerName = "";

  /**
   * @generated from field: aiserver.v1.DocumentSymbol.Range range = 6;
   */
  range?: DocumentSymbol_Range;

  /**
   * @generated from field: aiserver.v1.DocumentSymbol.Range selection_range = 7;
   */
  selectionRange?: DocumentSymbol_Range;

  /**
   * @generated from field: repeated aiserver.v1.DocumentSymbol children = 8;
   */
  children: DocumentSymbol[] = [];

  constructor(data?: PartialMessage<DocumentSymbol>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.DocumentSymbol";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "detail", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "kind", kind: "enum", T: proto3.getEnumType(DocumentSymbol_SymbolKind) },
    { no: 5, name: "container_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "range", kind: "message", T: DocumentSymbol_Range },
    { no: 7, name: "selection_range", kind: "message", T: DocumentSymbol_Range },
    { no: 8, name: "children", kind: "message", T: DocumentSymbol, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DocumentSymbol {
    return new DocumentSymbol().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DocumentSymbol {
    return new DocumentSymbol().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DocumentSymbol {
    return new DocumentSymbol().fromJsonString(jsonString, options);
  }

  static equals(a: DocumentSymbol | PlainMessage<DocumentSymbol> | undefined, b: DocumentSymbol | PlainMessage<DocumentSymbol> | undefined): boolean {
    return proto3.util.equals(DocumentSymbol, a, b);
  }
}

/**
 * @generated from enum aiserver.v1.DocumentSymbol.SymbolKind
 */
export enum DocumentSymbol_SymbolKind {
  /**
   * @generated from enum value: SYMBOL_KIND_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: SYMBOL_KIND_FILE = 1;
   */
  FILE = 1,

  /**
   * @generated from enum value: SYMBOL_KIND_MODULE = 2;
   */
  MODULE = 2,

  /**
   * @generated from enum value: SYMBOL_KIND_NAMESPACE = 3;
   */
  NAMESPACE = 3,

  /**
   * @generated from enum value: SYMBOL_KIND_PACKAGE = 4;
   */
  PACKAGE = 4,

  /**
   * @generated from enum value: SYMBOL_KIND_CLASS = 5;
   */
  CLASS = 5,

  /**
   * @generated from enum value: SYMBOL_KIND_METHOD = 6;
   */
  METHOD = 6,

  /**
   * @generated from enum value: SYMBOL_KIND_PROPERTY = 7;
   */
  PROPERTY = 7,

  /**
   * @generated from enum value: SYMBOL_KIND_FIELD = 8;
   */
  FIELD = 8,

  /**
   * @generated from enum value: SYMBOL_KIND_CONSTRUCTOR = 9;
   */
  CONSTRUCTOR = 9,

  /**
   * @generated from enum value: SYMBOL_KIND_ENUM = 10;
   */
  ENUM = 10,

  /**
   * @generated from enum value: SYMBOL_KIND_INTERFACE = 11;
   */
  INTERFACE = 11,

  /**
   * @generated from enum value: SYMBOL_KIND_FUNCTION = 12;
   */
  FUNCTION = 12,

  /**
   * @generated from enum value: SYMBOL_KIND_VARIABLE = 13;
   */
  VARIABLE = 13,

  /**
   * @generated from enum value: SYMBOL_KIND_CONSTANT = 14;
   */
  CONSTANT = 14,

  /**
   * @generated from enum value: SYMBOL_KIND_STRING = 15;
   */
  STRING = 15,

  /**
   * @generated from enum value: SYMBOL_KIND_NUMBER = 16;
   */
  NUMBER = 16,

  /**
   * @generated from enum value: SYMBOL_KIND_BOOLEAN = 17;
   */
  BOOLEAN = 17,

  /**
   * @generated from enum value: SYMBOL_KIND_ARRAY = 18;
   */
  ARRAY = 18,

  /**
   * @generated from enum value: SYMBOL_KIND_OBJECT = 19;
   */
  OBJECT = 19,

  /**
   * @generated from enum value: SYMBOL_KIND_KEY = 20;
   */
  KEY = 20,

  /**
   * @generated from enum value: SYMBOL_KIND_NULL = 21;
   */
  NULL = 21,

  /**
   * @generated from enum value: SYMBOL_KIND_ENUM_MEMBER = 22;
   */
  ENUM_MEMBER = 22,

  /**
   * @generated from enum value: SYMBOL_KIND_STRUCT = 23;
   */
  STRUCT = 23,

  /**
   * @generated from enum value: SYMBOL_KIND_EVENT = 24;
   */
  EVENT = 24,

  /**
   * @generated from enum value: SYMBOL_KIND_OPERATOR = 25;
   */
  OPERATOR = 25,

  /**
   * @generated from enum value: SYMBOL_KIND_TYPE_PARAMETER = 26;
   */
  TYPE_PARAMETER = 26,
}
// Retrieve enum metadata with: proto3.getEnumType(DocumentSymbol_SymbolKind)
proto3.util.setEnumType(DocumentSymbol_SymbolKind, "aiserver.v1.DocumentSymbol.SymbolKind", [
  { no: 0, name: "SYMBOL_KIND_UNSPECIFIED" },
  { no: 1, name: "SYMBOL_KIND_FILE" },
  { no: 2, name: "SYMBOL_KIND_MODULE" },
  { no: 3, name: "SYMBOL_KIND_NAMESPACE" },
  { no: 4, name: "SYMBOL_KIND_PACKAGE" },
  { no: 5, name: "SYMBOL_KIND_CLASS" },
  { no: 6, name: "SYMBOL_KIND_METHOD" },
  { no: 7, name: "SYMBOL_KIND_PROPERTY" },
  { no: 8, name: "SYMBOL_KIND_FIELD" },
  { no: 9, name: "SYMBOL_KIND_CONSTRUCTOR" },
  { no: 10, name: "SYMBOL_KIND_ENUM" },
  { no: 11, name: "SYMBOL_KIND_INTERFACE" },
  { no: 12, name: "SYMBOL_KIND_FUNCTION" },
  { no: 13, name: "SYMBOL_KIND_VARIABLE" },
  { no: 14, name: "SYMBOL_KIND_CONSTANT" },
  { no: 15, name: "SYMBOL_KIND_STRING" },
  { no: 16, name: "SYMBOL_KIND_NUMBER" },
  { no: 17, name: "SYMBOL_KIND_BOOLEAN" },
  { no: 18, name: "SYMBOL_KIND_ARRAY" },
  { no: 19, name: "SYMBOL_KIND_OBJECT" },
  { no: 20, name: "SYMBOL_KIND_KEY" },
  { no: 21, name: "SYMBOL_KIND_NULL" },
  { no: 22, name: "SYMBOL_KIND_ENUM_MEMBER" },
  { no: 23, name: "SYMBOL_KIND_STRUCT" },
  { no: 24, name: "SYMBOL_KIND_EVENT" },
  { no: 25, name: "SYMBOL_KIND_OPERATOR" },
  { no: 26, name: "SYMBOL_KIND_TYPE_PARAMETER" },
]);

/**
 * everything here is 1-indexed
 *
 * @generated from message aiserver.v1.DocumentSymbol.Range
 */
export class DocumentSymbol_Range extends Message<DocumentSymbol_Range> {
  /**
   * @generated from field: int32 start_line_number = 1;
   */
  startLineNumber = 0;

  /**
   * @generated from field: int32 start_column = 2;
   */
  startColumn = 0;

  /**
   * @generated from field: int32 end_line_number = 3;
   */
  endLineNumber = 0;

  /**
   * @generated from field: int32 end_column = 4;
   */
  endColumn = 0;

  constructor(data?: PartialMessage<DocumentSymbol_Range>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.DocumentSymbol.Range";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "start_line_number", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "start_column", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "end_line_number", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "end_column", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DocumentSymbol_Range {
    return new DocumentSymbol_Range().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DocumentSymbol_Range {
    return new DocumentSymbol_Range().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DocumentSymbol_Range {
    return new DocumentSymbol_Range().fromJsonString(jsonString, options);
  }

  static equals(a: DocumentSymbol_Range | PlainMessage<DocumentSymbol_Range> | undefined, b: DocumentSymbol_Range | PlainMessage<DocumentSymbol_Range> | undefined): boolean {
    return proto3.util.equals(DocumentSymbol_Range, a, b);
  }
}

